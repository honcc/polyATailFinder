#!/usr/bin/perl -w

#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
use strict;
use File::Path;
use Time::HiRes qw( time );
use Math::Random;
use Math::Round;
use Storable;
use Getopt::Long;
use File::Basename;
use File::Spec::Functions qw(rel2abs);
use List::Util qw (sum shuffle min max);
use threads;
use threads::shared;
use Statistics::Descriptive;
use URI::Escape;
use Cwd 'abs_path';
use Fcntl qw(:flock SEEK_END);
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
#	Description
#		This is a perl script to define polyA clusters and assign to genes and report the cluster properties.
#
#	Input
#		--gffPath=							file path[compulsory]; path of the reference GFF for gene annotation;
#		--fastaPath=						file path [compulsory]; the path fasta file contains the genome sequence, for generating blank perl storables;
#		--polyACntgPosAvgTailLenHshPlsPath=	file path [compulsory]; the path of the storable of the polyACntgPosAvgTailLenHsh hash, generated by BAMPolyAFilterer;
#		--mRNATrnsfrgOvrlpInfoHshPlsPath=	file path [none]; the path to mRNATrnsfrgOvrlpInfoHsh.pls generated in cisNATFinder, for sorting of cisNAT types for motif finding, if 'none', will not perform cisNAT type analyses;
#		--controlPileupIndexPath=			file path [compulsory]; path of the full read pileup index.hsh.pls which will be used for controlling the background of false postives;
#		--IGVGenomePath=					file path [compulsory]; the path of IGV .genome file;
#		--tophatBEDPath=					file path [optional]; the path of Bed file generated from tophat, to prevent treating intron as gaps when assigning polyA clusters to mRNA;
#		--maxThread=						integer [4]; max number of threads to be used;
#		--outDir=							directory path ['./BAMToReadEndPerlStorable/']; output directory;
#
#	v0.1
#		[Tue 27 Aug 2013 19:16:24 CEST] debut;
#
#	v0.2
#		[16/10/2013 11:20] mRNATrnsfrgOvrlpInfoHshPlsPath option added; will take the trnsfrg info optionally;
#

#	/Volumes/A_MPro2TB/softwareForNGS/myPerlScripts/transcriptModel/polyATailFinder/v0.2/polyATailFinder_v0.2.pl
#	--polyACntgPosAvgTailLenHshPlsPath=/Volumes/A_MPro2TB/NGS/analyses/EHI_polyA/tophatPipeMapping/EHI_polyA_mapping/BAMPolyAFilterer/polyA.NR.no.DR10.8.UR10.8.DT6.6.EM2.TB5.DD80.RP70.ML20.AL5.TA3/storable/polyACntgPosAvgTailLenHsh.pls
#	--mRNATrnsfrgOvrlpInfoHshPlsPath=/Volumes/A_MPro2TB/softwareForNGS/myPerlScripts/antisenseTranscripts/cisNATFinder/v0.2/EHI_Standard_CL0.95/ID50.OS50.RG5.ML1000/storable/mRNATrnsfrgOvrlpInfoHsh.pls
#	--fastaPath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/fasta/genome.sorted.fa
#	--gffPath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/gff/forPileupCounter.gff
#	--maxThread=8
#	--IGVGenomePath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/IGVGenome/EHI_v3.0.genome
#	--controlPileupIndexPath=/Volumes/C_Analysis/NGS/results/E011_TEX5Map_basic_min35nt/E011_optTEX5Map_TEXminusTAPminus/mergedBam/BAMToReadEndPerlStorable/countMode.full.offset.0.baseComp.no/cntgCovPls/index.hsh.pls
#	--tophatBEDPath=/Volumes/C_Analysis/NGS/results/E003_polyAPair_EHI_tophatRemap/junctions/allSixLibJunctions.bed
#	--outDir=/Volumes/A_MPro2TB/NGS/analyses/EHI_polyA/polyATailFinderTop3RdALen/

#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	[2013-10-16 20:57]	/Volumes/A_MPro2TB/softwareForNGS/myPerlScripts/transcriptModel/polyATailFinder/v0.2/polyATailFinder_v0.2.pl --polyACntgPosAvgTailLenHshPlsPath=/Volumes/A_MPro2TB/NGS/analyses/EHI_polyA/tophatPipeMapping/EHI_polyA_mapping/BAMPolyAFilterer/polyA.NR.no.DR10.8.UR10.8.DT6.6.EM2.TB5.DD80.RP70.ML20.AL5.TA3/storable/polyACntgPosAvgTailLenHsh.pls --mRNATrnsfrgOvrlpInfoHshPlsPath=/Volumes/A_MPro2TB/softwareForNGS/myPerlScripts/antisenseTranscripts/cisNATFinder/v0.2/EHI_Standard_CL0.95/ID50.OS50.RG5.ML1000/storable/mRNATrnsfrgOvrlpInfoHsh.pls --fastaPath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/fasta/genome.sorted.fa --gffPath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/gff/forPileupCounter.gff --maxThread=8 --IGVGenomePath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/IGVGenome/EHI_v3.0.genome --controlPileupIndexPath=/Volumes/C_Analysis/NGS/results/E011_TEX5Map_basic_min35nt/E011_optTEX5Map_TEXminusTAPminus/mergedBam/BAMToReadEndPerlStorable/countMode.full.offset.0.baseComp.no/cntgCovPls/index.hsh.pls --tophatBEDPath=/Volumes/C_Analysis/NGS/results/E003_polyAPair_EHI_tophatRemap/junctions/allSixLibJunctions.bed --outDir=/Volumes/A_MPro2TB/NGS/analyses/EHI_polyA/polyATailFinderTop3RdALen/
#
#	/Volumes/A_MPro2TB/softwareForNGS/myPerlScripts/transcriptModel/polyATailFinder/v0.2/polyATailFinder_v0.2.pl
#	--polyACntgPosAvgTailLenHshPlsPath=/Volumes/A_MPro2TB/NGS/analyses/EHI_polyA/tophatPipeMapping/EHI_polyA_mapping/BAMPolyAFilterer/polyA.NR.no.DR10.8.UR10.8.DT6.6.EM2.TB5.DD80.RP70.ML20.AL5.TA3/storable/polyACntgPosAvgTailLenHsh.pls
#	--mRNATrnsfrgOvrlpInfoHshPlsPath=/Volumes/A_MPro2TB/softwareForNGS/myPerlScripts/antisenseTranscripts/cisNATFinder/v0.2/EHI_Standard_CL0.95/ID50.OS50.RG5.ML1000/storable/mRNATrnsfrgOvrlpInfoHsh.pls
#	--fastaPath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/fasta/genome.sorted.fa
#	--gffPath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/gff/forPileupCounter.gff
#	--maxThread=8
#	--IGVGenomePath=/Volumes/A_MPro2TB/softwareForNGS/resources/genome/AmoebaDB/inUse/AmoebaDB-3.0/EHI/IGVGenome/EHI_v3.0.genome
#	--controlPileupIndexPath=/Volumes/C_Analysis/NGS/results/E011_TEX5Map_basic_min35nt/E011_optTEX5Map_TEXminusTAPminus/mergedBam/BAMToReadEndPerlStorable/countMode.full.offset.0.baseComp.no/cntgCovPls/index.hsh.pls
#	--tophatBEDPath=/Volumes/C_Analysis/NGS/results/E003_polyAPair_EHI_tophatRemap/junctions/allSixLibJunctions.bed
#	--outDir=/Volumes/A_MPro2TB/NGS/analyses/EHI_polyA/polyATailFinderTop3RdALen/
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $globalScriptDirPath = dirname(rel2abs($0));
open my $FHDebugLog, ">", "$globalScriptDirPath/debug.log.txt";
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#	primaryDependOnSub: printCMDLogOrFinishMessage|4199, readParameters|4698
#	secondaryDependOnSub: currentTime|1872
#
#<section ID="startingTasks" num="0">
&printCMDLogOrFinishMessage("CMDLog");#->4199
my ($gffPath, $fastaPath, $polyACntgPosAvgTailLenHshPlsPath, $controlPileupIndexPath, $IGVGenomePath, $maxThread, $tophatBEDPath, $mRNATrnsfrgOvrlpInfoHshPlsPath, $outDir) = &readParameters();#->4698
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#	primaryDependOnSub: plotValidPolyASiteAroundGenes|4049
#	secondaryDependOnSub: plotCoverageAroundGene|3867
#
#<section ID="defineHardCodedParam" num="1">
my $analyzeEnd3PolyAMotif = 'yes'; #---[yes or no], to run couting and dreme for end3Nat region in &analyzeEnd3PolyAMotifEnrichment
my $clstrSeqRng = 200; #---[integer], length of the region surrounding the polyA peak site to be sampled in &getClstrSequence
my $minCDSLenPolyOccurencePlot = 1000;
my $cleavageSiteSeqPosHsh_ref = {'upStrmStart'=> -8, 'dnStrmEnd'=> 1};#---[14/10/2013 13:51] to get the cleavage site motif, upStrmStart refers to the number of base get from the last nt of the upstream sequence, dnStrmEnd refers number of base get from the first nt of the dnstream sequence;

my $indivPolyASiteCutoffHsh_ref = {};
$indivPolyASiteCutoffHsh_ref->{'minAvgRdATailLen'} = 12; #---position with minimum average polyA tail length to be used
$indivPolyASiteCutoffHsh_ref->{'minRdNum'} = 3; #---position with that minimum number of read to be used

#=pod
#---[07/10/2013 15:44] Amoeba parameters
my @mRNAAry = qw/bfmRNA/;
my $srchSensePolyAOutterBound = 200;#[auto or integer]---determine the region to be search for sense polyA tail; if auto, will be determined by cutoff of the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
my $srchAntiSensePolyAOutterBound = 200; #[auto or integer] ---the range to search for antisense polyA upstream of ATG; if auto, will be determined by from the intergenetic distance percentile;
my $maxCovGap = 20; #[auto or integer] ---determine maximum tolerated gap between sense polyA tail; if auto, will be determined by cutoff of the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
my $initialOutterBound = 500; #[auto or integer] ---the initial bound outside ATG and TAA for plotting valid polyA sites; if auto, will be determined by cutoff of the percentile of intergenic distance;
my $plotInnerBound = 1000; #[auto or integer] ---the range within CDS to be plot in &plotValidPolyASiteAroundGenes; if auto, will be determined by cutoff of the percentile of CDS length;
my $end3ASPolyARng = 1000; #[auto or integer] ---the range at the 3'end of gene for searching antisense polyA at 3'end;if auto, will be determined by cutoff of the percentile of CDS length;
my $maxPrxmty = 1000; #[auto or integer] ---the maximum intergenic distance to be qualified as mRNA pairs; if auto, will be determined by cutoff of the percentile of intergenic distance;
my $minPrxmty = 10; #[auto or integer] ---the minimum intergenic distance to be qualified as mRNA pairs, if auto, will be determined by cutoff of the percentile of intergenic distance;
#=cut

=pod
#---[07/10/2013 15:44] Damien parameters
my @mRNAAry = qw/mRNA/;
my $srchSensePolyAOutterBound = 1000;#[auto or integer]---determine the region to be search for sense polyA tail; if auto, will be determined by cutoff of the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
my $srchAntiSensePolyAOutterBound = 500; #[auto or integer] ---the range to search for antisense polyA upstream of ATG; if auto, will be determined by from the intergenetic distance percentile;
my $maxCovGap = 30; #[auto or integer] ---determine maximum tolerated gap between sense polyA tail; if auto, will be determined by cutoff of the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
my $initialOutterBound = 1500; #[auto or integer] ---the initial bound outside ATG and TAA for plotting valid polyA sites; if auto, will be determined by cutoff of the percentile of intergenic distance;
my $plotInnerBound = 1500; #[auto or integer] ---the range within CDS to be plot in &plotValidPolyASiteAroundGenes; if auto, will be determined by cutoff of the percentile of CDS length;
my $end3ASPolyARng = 500; #[auto or integer] ---the range at the 3'end of gene for searching antisense polyA at 3'end;if auto, will be determined by cutoff of the percentile of CDS length;
my $maxPrxmty = 2000; #[auto or integer] ---the maximum intergenic distance to be qualified as mRNA pairs; if auto, will be determined by cutoff of the percentile of intergenic distance;
my $minPrxmty = 10; #[auto or integer] ---the minimum intergenic distance to be qualified as mRNA pairs, if auto, will be determined by cutoff of the percentile of intergenic distance;
=cut

#---[07/10/2013 09:45] will be used only if "auto" in the above parameter
my $srchSensePolyAOutterBound_cutoffPct = 85; #[1 5 10 25 50 65 75 85 90 95 97 99] #---determine the region to be search for sense polyA tail, by cutoff of the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
my $srchAntiSensePolyAOutterBound_cutoffPct = 25; #[1 5 10 25 50 65 75 85 90 95 97 99] #---the range to search for antisense polyA upstream of ATG, determined from the intergenetic distance percentile;
my $maxCovGap_cutoffPct = 10; #[1 5 10 25 50 65 75 85 90 95 97 99] #---determine maximum tolerated gap between sense polyA tail, by cutoff of the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
my $initialOutterBound_cutoffPct = 50; #[1 5 10 25 50 65 75 85 90 95 97 99] #---the initial bound outside ATG and TAA for plotting valid polyA sites, by cutoff of the percentile of intergenic distance;
my $plotInnerBound_cutoffPct = 50; #[1 5 10 25 50 65 75 85 90 95 97 99] #---the range within CDS to be plot in &plotValidPolyASiteAroundGenes, by cutoff of the percentile of CDS length;
my $end3ASPolyARng_cutoffPct = 25; #[1 5 10 25 50 65 75 85 90 95 97 99] #---the range at the 3'end of gene for searching antisense polyA at 3'end, by cutoff of the percentile of CDS length;
my $maxPrxmty_cutoffPct = 50; #[1 5 10 25 50 65 75 85 90 95 97 99] #---the maximum intergenic distance to be qualified as mRNA pairs, by cutoff of the percentile of intergenic distance;
my $minPrxmty_cutoffPct = 1; #[1 5 10 25 50 65 75 85 90 95 97 99] #---the minimum intergenic distance to be qualified as mRNA pairs, by cutoff of the percentile of intergenic distance;

my $abvBkgdPctCutoffHsh_ref = {};
$abvBkgdPctCutoffHsh_ref->{'polyAToCntrlCountRatio'} = 95; #---any integer, trainning.polyACountWithZeroCntrl.histogram.pdf
$abvBkgdPctCutoffHsh_ref->{'polyACountWithZeroCntrl'} = 95; #---any integer, trainning.polyAToCntrlCountRatio.histogram.pdf

my $paramTag = join ".",
(
	'IA'.$indivPolyASiteCutoffHsh_ref->{'minAvgRdATailLen'},
	'IR'.$indivPolyASiteCutoffHsh_ref->{'minRdNum'},
	'BR'.$abvBkgdPctCutoffHsh_ref->{'polyAToCntrlCountRatio'},
	'BC'.$abvBkgdPctCutoffHsh_ref->{'polyACountWithZeroCntrl'},
	'SS'.$srchSensePolyAOutterBound,
	'SA'.$srchAntiSensePolyAOutterBound,
	'MG'.$maxCovGap,
	'OB'.$initialOutterBound,
	'PB'.$plotInnerBound,
	'AP'.$end3ASPolyARng,
	'MP'.$maxPrxmty,
	'NP'.$minPrxmty,
);

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#	primaryDependOnSub: >none
#	secondaryDependOnSub: >none
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $resultDir = "$outDir/$paramTag/"; push @mkDirAry, $resultDir;
my $resultStorableDir = "$resultDir/storable/"; push @mkDirAry, $resultStorableDir;
my $resultWigDir = "$resultDir/wig/"; push @mkDirAry, $resultWigDir;
my $resultLogDir = "$resultDir/log/"; push @mkDirAry, $resultLogDir;
my $resultDremeDir = "$resultDir/dreme/"; push @mkDirAry, $resultDremeDir;
my $resultMotifDir = "$resultDir/motif/"; push @mkDirAry, $resultMotifDir;
my $ggplotDirHsh_ref = {};
foreach (qw /dat pdf R log/) {$ggplotDirHsh_ref->{$_} = "$resultDir/ggplot/$_"; push @mkDirAry, $ggplotDirHsh_ref->{$_};}
my $weblogoDirHsh_ref = {};
foreach (qw /pdf fasta cmd/) {$weblogoDirHsh_ref->{$_} = "$resultDir/weblogo/$_"; push @mkDirAry, $weblogoDirHsh_ref->{$_};}
foreach (@mkDirAry) {system ("mkdir -pm 777 $_");}
open my $FH_paramValueLog, ">", "$resultLogDir/paramValue.log.txt"; #----to log the actual values used for cutoffs
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_defineOutFilePath
#	primaryDependOnSub: >none
#	secondaryDependOnSub: >none
#
#<section ID="defineOutFilePath" num="3">
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_processGenomeInformation
#	primaryDependOnSub: checkGeneInfo|959, checkmRNAProximity|1255, classifymRNABasedOnProximity|1286, generateGeneByCntgHsh|2537, getCtgryGeneInfo|2734, getIntergenicDistanceAndCDSLength|2857, printBothFHAndStdout|4176, printPrxmtyInfoLog|4398, readGFF_oneRNAPerGene|4534, readMultiFasta|4644
#	secondaryDependOnSub: checkOverlapAndProximity|987, currentTime|1872, ggplotHistogram|3444, reportStatus|4806
#
#<section ID="processGenomeInformation" num="4">
#---Read Fasta and gene info
my ($fastaHsh_ref) = &readMultiFasta($fastaPath);#->4644
my ($geneInfoHsh_ref) = &readGFF_oneRNAPerGene($gffPath);#->4534
my ($geneByCntgHsh_ref) = &generateGeneByCntgHsh($geneInfoHsh_ref);#->2537
&checkGeneInfo($geneInfoHsh_ref);#->959
my ($mRNAInfoHsh_ref, $mRNAByCntgHsh_ref)= &getCtgryGeneInfo($geneInfoHsh_ref, \@mRNAAry);#->2734
my ($hitAndPrxmtyBymRNAHsh_ref) = &checkmRNAProximity($resultStorableDir, $geneInfoHsh_ref, $mRNAInfoHsh_ref, $maxThread);#->1255
&printPrxmtyInfoLog($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $geneInfoHsh_ref, $resultLogDir, undef);#->4398
my ($intGenicDistPctHsh_ref, $CDSLengthPctHsh_ref) = &getIntergenicDistanceAndCDSLength($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $ggplotDirHsh_ref, $resultStorableDir);#->2857

#---define the bounds based on intergenic and CDS info, round-off to nearest 50nt
$minPrxmty = nearest(50, $intGenicDistPctHsh_ref->{$minPrxmty_cutoffPct}) if $minPrxmty eq 'auto';
$maxPrxmty = nearest(50, $intGenicDistPctHsh_ref->{$maxPrxmty_cutoffPct}) if $maxPrxmty eq 'auto';
$initialOutterBound = nearest(50, $intGenicDistPctHsh_ref->{$initialOutterBound_cutoffPct}) if $initialOutterBound eq 'auto';#---the initial bound outside ATG and TAA for plotting valid polyA sites
$plotInnerBound = nearest(50, $CDSLengthPctHsh_ref->{$plotInnerBound_cutoffPct}) if $plotInnerBound eq 'auto';#---the range within CDS to be plot in &plotValidPolyASiteAroundGenes;
$end3ASPolyARng = nearest(50, $CDSLengthPctHsh_ref->{$end3ASPolyARng_cutoffPct}) if $end3ASPolyARng eq 'auto';#---the range at the 3'end of gene for searching antisense polyA at 3'end;
&printBothFHAndStdout("minPrxmty = $minPrxmty", 10, $FH_paramValueLog);#->4176
&printBothFHAndStdout("maxPrxmty = $maxPrxmty", 10, $FH_paramValueLog);#->4176
&printBothFHAndStdout("initialOutterBound = $initialOutterBound", 10, $FH_paramValueLog);#->4176
&printBothFHAndStdout("plotInnerBound = $plotInnerBound", 10, $FH_paramValueLog);#->4176
&printBothFHAndStdout("end3ASPolyARng = $end3ASPolyARng", 10, $FH_paramValueLog);#->4176

my ($mRNAPrxmtyClassListHsh_ref) = &classifymRNABasedOnProximity($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $minPrxmty, $maxPrxmty);#->1286

#---[08/10/2013 11:56] release memory
undef $hitAndPrxmtyBymRNAHsh_ref;

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 5_getValidPolyASitesAndPlotRawDistribution
#	primaryDependOnSub: getIndivCntgCovPlsPath|2824, getRawPolyASite|2977, zipUnzipCntgCovInPlsPathHsh|4866
#	secondaryDependOnSub: createEmptyGenomeCovPerlStorable|1770, currentTime|1872, printWigFromCovPerlStorable|4474, reportStatus|4806
#
#<section ID="getValidPolyASitesAndPlotRawDistribution" num="5">

#---get polyA pls
my ($rawPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref) = &getRawPolyASite($polyACntgPosAvgTailLenHshPlsPath, $fastaHsh_ref, $resultStorableDir, $IGVGenomePath, $resultWigDir);#->2977
&zipUnzipCntgCovInPlsPathHsh('unzip', $rawPolyASitePlsPathHsh_ref);#->4866
&zipUnzipCntgCovInPlsPathHsh('unzip', $polyATailLenPlsPathHsh_ref);#->4866

#---get control pls
my ($controlPileupPlsPathHsh_ref) = &getIndivCntgCovPlsPath($controlPileupIndexPath);#->2824
&zipUnzipCntgCovInPlsPathHsh('unzip', $controlPileupPlsPathHsh_ref);#->4866
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 6_filterAbovebackgroundPolyASites
#	primaryDependOnSub: filterValidPolyASite|2140, getNonStructuralCount|2953, trainingUsingCDSVsUTR3|4829
#	secondaryDependOnSub: countCtgryOnCntg|1521, createEmptyGenomeCovPerlStorable|1770, getUTR3AndCDSPosCov|3212, plotCDSToUTR3Ratio|3801, printWigFromCovPerlStorable|4474, reportStatus|4806
#
#<section ID="filterAbovebackgroundPolyASites" num="6">
my ($abvBkgdValCutoffHsh_ref) = &trainingUsingCDSVsUTR3($controlPileupPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $maxThread, $ggplotDirHsh_ref, $abvBkgdPctCutoffHsh_ref, $resultStorableDir);#->4829
my ($validPolyASitePlsPathHsh_ref) = &filterValidPolyASite($rawPolyASitePlsPathHsh_ref, $controlPileupPlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $abvBkgdValCutoffHsh_ref, $indivPolyASiteCutoffHsh_ref, $resultStorableDir, $fastaHsh_ref, $IGVGenomePath, $resultWigDir);#->2140
#---get nonStructuralCount for later use in normalization in plotting plotValidPolyASiteAroundGenes
my ($nonStructuralCountHsh_ref) = &getNonStructuralCount($validPolyASitePlsPathHsh_ref, $controlPileupPlsPathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir);#->2953
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 7_plotRawDistribution
#	primaryDependOnSub: getSenseTailPolyASiteDistribution|3047, getValidPolyASiteDistribution|3344, plotValidPolyASiteAroundGenes|4049
#	secondaryDependOnSub: getCoverageOfItemRngType_multiStrand|2627, ggplotHistogram|3444, plotCoverageAroundGene|3867, reportStatus|4806
#
#<section ID="plotRawDistribution" num="7">
my ($validPolyASiteDstrbtnHsh_ref) = &getValidPolyASiteDistribution($validPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $initialOutterBound, $maxThread, $resultStorableDir);#->3344
my ($senseTailPolyAPctHsh_ref) = &getSenseTailPolyASiteDistribution($mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $initialOutterBound, $validPolyASitePlsPathHsh_ref, $ggplotDirHsh_ref, $resultStorableDir);#->3047
my $nonStructuralCount = $nonStructuralCountHsh_ref->{'polyA'};
&plotValidPolyASiteAroundGenes($validPolyASiteDstrbtnHsh_ref, $nonStructuralCount, $initialOutterBound, $plotInnerBound, $ggplotDirHsh_ref, $resultStorableDir, $mRNAInfoHsh_ref, $mRNAPrxmtyClassListHsh_ref, $resultLogDir);#->4049
undef $validPolyASiteDstrbtnHsh_ref;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 8_findOptimalGapSizeAndClusterPolyASites
#	primaryDependOnSub: optimizeGapSizeAndClstrPolyASites|3657
#	secondaryDependOnSub: clusterPolyASites|1334, ggplotXYLineSingleSample|3587, reportStatus|4806
#
#<section ID="findOptimalGapSizeAndClusterPolyASites" num="8">
my ($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref) = &optimizeGapSizeAndClstrPolyASites($maxThread, $validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $resultStorableDir, $ggplotDirHsh_ref);#->3657
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 9_assignPolyAClustersToGenes
#	primaryDependOnSub: assignAntiSensePolyAClusterTomRNAHead|502, assignPolyAClusterTomRNABody|573, assignSensePolyAClusterTomRNATail|658, printBothFHAndStdout|4176, readTophatBEDFile|4740
#	secondaryDependOnSub: currentTime|1872, printBothFHAndStdout|4176, reportStatus|4806
#
#<section ID="assignPolyAClustersToGenes" num="9">
$srchSensePolyAOutterBound = $senseTailPolyAPctHsh_ref->{$srchSensePolyAOutterBound_cutoffPct} if $srchSensePolyAOutterBound eq 'auto';#---take the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]
$srchAntiSensePolyAOutterBound = $intGenicDistPctHsh_ref->{$srchAntiSensePolyAOutterBound_cutoffPct} if $srchAntiSensePolyAOutterBound eq 'auto';#---the range to search for antisense polyA upstream of ATG, determined from the intergenetic distance percentile;
$maxCovGap = $senseTailPolyAPctHsh_ref->{$maxCovGap_cutoffPct} if $maxCovGap eq 'auto';#---take the percentile from the distribution generated in &getSenseTailPolyASiteDistribution [valid.polyASite.dstrbtn.pdf]

my (undef, $jnctnByPosHsh_ref) = &readTophatBEDFile($tophatBEDPath, $resultStorableDir);#->4740
&printBothFHAndStdout("srchSensePolyAOutterBound = $srchSensePolyAOutterBound", 10, $FH_paramValueLog);#->4176
&printBothFHAndStdout("srchAntiSensePolyAOutterBound = $srchAntiSensePolyAOutterBound", 10, $FH_paramValueLog);#->4176
&printBothFHAndStdout("maxCovGap = $maxCovGap", 10, $FH_paramValueLog);#->4176
my ($mRNATailSensePolyAInfoHsh_ref) = &assignSensePolyAClusterTomRNATail($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $controlPileupPlsPathHsh_ref, $srchSensePolyAOutterBound, $maxCovGap, $jnctnByPosHsh_ref, $resultStorableDir, $FH_paramValueLog);#->658
my ($mRNAGeneBodyPolyAInfoHsh_ref) = &assignPolyAClusterTomRNABody($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $resultStorableDir, $FH_paramValueLog);#->573
my ($mRNAHeadAntiSensePolyAInfoHsh_ref) = &assignAntiSensePolyAClusterTomRNAHead($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $srchAntiSensePolyAOutterBound, $resultStorableDir, $FH_paramValueLog);#->502
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 10_gatherAndReportPolyAInfo
#	primaryDependOnSub: calculatePolyAOccurenceWithinCDSOnBothStrand|815, gatherPolyAInfo|2224, printClusterInfoAndWig|4232, printGeneBasedInfo|4343
#	secondaryDependOnSub: getClstrSequence|2585, ggplotXYLinesMultipleSamples|3622, reportStatus|4806
#
#<section ID="gatherAndReportPolyAInfo" num="10">
my ($mRNABasedPolyAInfoHsh_ref, $clstrBasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref) = &gatherPolyAInfo($mRNATailSensePolyAInfoHsh_ref, $mRNAGeneBodyPolyAInfoHsh_ref, $mRNAHeadAntiSensePolyAInfoHsh_ref, $clstrInfoHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir);#->2224
&printClusterInfoAndWig($clstrBasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $resultLogDir, $resultWigDir, $fastaHsh_ref, $clstrSeqRng);#->4232
&printGeneBasedInfo($mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $resultLogDir, $polyATypeTagHsh_ref);#->4343
&calculatePolyAOccurenceWithinCDSOnBothStrand($mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $minCDSLenPolyOccurencePlot, $resultLogDir, $ggplotDirHsh_ref);#->815
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 11_investigatePolyAClstrMotif
#	primaryDependOnSub: categorizePolyAClstrForDreme|888, generateCleavageSiteWeblogoAndMotifFile|2400, generateDSEAndPASMotifFileFromDremeTxt|2501, plotBaseCompositionClstrPeak|3750
#	secondaryDependOnSub: calculateBaseCompositionInAlignments|762, createMotifFileFromBaseComposition|1811, createWeblogo|1845, dremePolyASiteMotif|2040, ggplotXYLinesMultipleSamples|3622, reportStatus|4806
#
#<section ID="investigatePolyAClstrMotif" num="11">
my ($polyADremePathHsh_ref, $clstrSeqHsh_ref, $cleavageSiteSeqHsh_ref) = &categorizePolyAClstrForDreme($clstrInfoHsh_ref, $clstrBasedPolyAInfoHsh_ref, $clstrSeqRng, $resultDremeDir, $cleavageSiteSeqPosHsh_ref);#->888
&generateDSEAndPASMotifFileFromDremeTxt($polyADremePathHsh_ref, $resultMotifDir);#->2501
my ($clstrSeqBaseProportionHsh_ref) = &plotBaseCompositionClstrPeak($clstrSeqHsh_ref, $ggplotDirHsh_ref, $clstrSeqRng);#->3750
&generateCleavageSiteWeblogoAndMotifFile($cleavageSiteSeqHsh_ref, $clstrSeqHsh_ref, $weblogoDirHsh_ref, $resultMotifDir, $clstrSeqBaseProportionHsh_ref);#->2400

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 12_investigateEnd3NATPolyA
#	primaryDependOnSub: analyzeEnd3PolyAMotifEnrichment|483, countMotifOccurenceInCDSWithShortAndLongCisNAT|1642, getmRNASeqWithEnd3AntisensePolyA|3379
#	secondaryDependOnSub: checkRunningThreadAndWaitToJoin|1227, countATGssTAAasMotif|1472, defineCDSWithLongAndShortCisNAT|1890, dremeATGssTAAasMotif|1979, generateDREMECmd|2445, getEnd3SequenceForCDSWithLongAndShortNAT|2771, getSeqOfItemRngType|3144, polymerDiscriminativeRatio|4102, printBothFHAndStdout|4176, reportStatus|4806
#
#<section ID="investigateEnd3NATPolyA" num="12">
my ($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $mRNAIDWithEnd3ASPolyAHsh_ref) = &getmRNASeqWithEnd3AntisensePolyA($mRNAGeneBodyPolyAInfoHsh_ref, $initialOutterBound, $end3ASPolyARng, $fastaHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir, $FH_paramValueLog);#->3379
if ($analyzeEnd3PolyAMotif eq 'yes') {
	&analyzeEnd3PolyAMotifEnrichment($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir, $resultDremeDir);#->483
}
&countMotifOccurenceInCDSWithShortAndLongCisNAT($mRNABasedPolyAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHshPlsPath, $mRNAInfoHsh_ref, $resultLogDir, $fastaHsh_ref, $resultDremeDir);#->1642

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 13_finishingTasks
#	primaryDependOnSub: printCMDLogOrFinishMessage|4199
#	secondaryDependOnSub: currentTime|1872
#
#<section ID="finishingTasks" num="13">
&printCMDLogOrFinishMessage("finishMessage");#->4199
close $FHDebugLog;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	alignment [n=1]:
#		calculateBaseCompositionInAlignments
#
#	baseComposition [n=2]:
#		calculateBaseCompositionInAlignments, plotBaseCompositionClstrPeak
#
#	coverage [n=1]:
#		getCoverageOfItemRngType_multiStrand
#
#	fasta [n=1]:
#		readMultiFasta
#
#	filehandle [n=2]:
#		FHLock, FHUnlock
#
#	general [n=9]:
#		checkGeneInfo, currentTime, getCtgryGeneInfo
#		printBothFHAndStdout, printCMDLogOrFinishMessage, readGFF_oneRNAPerGene
#		readMultiFasta, readParameters, reportStatus
#
#	gff [n=3]:
#		checkGeneInfo, generateGeneByCntgHsh, readGFF_oneRNAPerGene
#
#	ggplot [n=3]:
#		ggplotHistogram, ggplotXYLinesMultipleSamples, plotBaseCompositionClstrPeak
#
#	motif [n=1]:
#		dremePolyASiteMotif
#
#	multithread [n=2]:
#		checkRunningThreadAndWaitToJoin, generateThreadHshWithRandomCntg
#
#	plotInR [n=2]:
#		ggplotHistogram, ggplotXYLinesMultipleSamples
#
#	range [n=3]:
#		checkOverlapAndProximity, checkmRNAProximity, classifymRNABasedOnProximity
#
#	reporting [n=4]:
#		currentTime, printBothFHAndStdout, printClusterInfoAndWig
#		printGeneBasedInfo
#
#	specfic [n=1]:
#		printGeneBasedInfo
#
#	specific [n=11]:
#		analyzeEnd3PolyAMotifEnrichment, calculatePolyAOccurenceWithinCDSOnBothStrand, categorizePolyAClstrForDreme
#		countMotifOccurenceInCDSWithShortAndLongCisNAT, defineCDSWithLongAndShortCisNAT, gatherPolyAInfo
#		generateCleavageSiteWeblogoAndMotifFile, generateDSEAndPASMotifFileFromDremeTxt, getClstrSequence
#		getEnd3SequenceForCDSWithLongAndShortNAT, printClusterInfoAndWig
#
#	storable [n=3]:
#		createEmptyGenomeCovPerlStorable, getIndivCntgCovPlsPath, zipUnzipCntgCovInPlsPathHsh
#
#	thridPartyApp [n=2]:
#		createWeblogo, generateDREMECmd
#
#	unassigned [n=28]:
#		assignAntiSensePolyAClusterTomRNAHead, assignPolyAClusterTomRNABody, assignSensePolyAClusterTomRNATail
#		clusterPolyASites, countATGssTAAasMotif, countCtgryOnCntg
#		createMotifFileFromBaseComposition, dremeATGssTAAasMotif, filterValidPolyASite
#		getIntergenicDistanceAndCDSLength, getNonStructuralCount, getRawPolyASite
#		getSenseTailPolyASiteDistribution, getSeqOfItemRngType, getUTR3AndCDSPosCov
#		getValidPolyASiteDistribution, getmRNASeqWithEnd3AntisensePolyA, ggplotMultiSampleHistogram
#		ggplotXYLineSingleSample, optimizeGapSizeAndClstrPolyASites, plotCDSToUTR3Ratio
#		plotCoverageAroundGene, plotValidPolyASiteAroundGenes, polymerDiscriminativeRatio
#		printPrxmtyInfoLog, printWigFromCovPerlStorable, readTophatBEDFile
#		trainingUsingCDSVsUTR3
#
#====================================================================================================================================================#

sub FHLock {
#....................................................................................................................................................#
#	subroutineCategory: filehandle
#	dependOnSub: >none
#	appearInSub: getUTR3AndCDSPosCov|3212
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $fh
#	output: none
#	toCall: &FHLock($fh);
#	calledInLine: 3308
#....................................................................................................................................................#
	my ($fh) = @_;
	flock($fh, LOCK_EX) or die "Cannot lock mailbox - $!\n";
	# and, in case someone appended while we were waiting...
	seek($fh, 0, SEEK_END) or die "Cannot seek - $!\n";
}
sub FHUnlock {
#....................................................................................................................................................#
#	subroutineCategory: filehandle
#	dependOnSub: >none
#	appearInSub: getUTR3AndCDSPosCov|3212
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $fh
#	output: none
#	toCall: &FHUnlock($fh);
#	calledInLine: 3310
#....................................................................................................................................................#
	my ($fh) = @_;
	flock($fh, LOCK_UN) or die "Cannot unlock mailbox - $!\n";
}
sub analyzeEnd3PolyAMotifEnrichment {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: countATGssTAAasMotif|1472, dremeATGssTAAasMotif|1979
#	appearInSub: >none
#	primaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	secondaryAppearInSection: >none
#	input: $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultDremeDir, $resultLogDir
#	output: 
#	toCall: &analyzeEnd3PolyAMotifEnrichment($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir, $resultDremeDir);
#	calledInLine: 354
#....................................................................................................................................................#
	my ($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir, $resultDremeDir) = @_;
	
	&countATGssTAAasMotif($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir);#->1472
	&dremeATGssTAAasMotif($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultDremeDir);#->1979

	return ();
}
sub assignAntiSensePolyAClusterTomRNAHead {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: printBothFHAndStdout|4176, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 9_assignPolyAClustersToGenes|300
#	secondaryAppearInSection: >none
#	input: $FH_paramValueLog, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir, $srchAntiSensePolyAOutterBound
#	output: $mRNAHeadAntiSensePolyAInfoHsh_ref
#	toCall: my ($mRNAHeadAntiSensePolyAInfoHsh_ref) = &assignAntiSensePolyAClusterTomRNAHead($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $srchAntiSensePolyAOutterBound, $resultStorableDir, $FH_paramValueLog);
#	calledInLine: 315
#....................................................................................................................................................#
	my ($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $srchAntiSensePolyAOutterBound, $resultStorableDir, $FH_paramValueLog) = @_;

	my $mRNAHeadAntiSensePolyAInfoHsh_ref = {};
	my $mRNAHeadAntiSensePolyAInfoHshPlsPath = "$resultStorableDir/mRNAHeadAntiSensePolyAInfoHsh.pls";
	
	if (-s $mRNAHeadAntiSensePolyAInfoHshPlsPath) {

		&reportStatus("Retrieving mRNAHeadAntiSensePolyAInfoHsh", 20, "\n");#->4806
		$mRNAHeadAntiSensePolyAInfoHsh_ref = retrieve($mRNAHeadAntiSensePolyAInfoHshPlsPath);

	} else {

		&reportStatus("Assigning polyA clusters to mRNA head", 20, "\n");#->4806
		
		my $mRNAProc = 0;
		my %tmpOppStrndHsh = ();
		$tmpOppStrndHsh{'+'} = '-';
		$tmpOppStrndHsh{'-'} = '+';

		my %tmpAssignedClstr = ();
		foreach my $cntg (keys %{$mRNAByCntgHsh_ref}) {

			foreach my $mRNAID (keys %{$mRNAByCntgHsh_ref->{$cntg}}) {
				$mRNAProc++;
				my $mRNAStrnd = $mRNAInfoHsh_ref->{$mRNAID}{'strnd'};
				
				&reportStatus("$mRNAProc mRNA processed", 30, "\r");#->4806
				my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
				my @srchRng = ();
				if ($mRNAStrnd eq '+') {
					@srchRng = reverse ($CDSRngAry[0]-$srchAntiSensePolyAOutterBound..$CDSRngAry[0]-1);
				} else {
					@srchRng = ($CDSRngAry[-1]+1..$CDSRngAry[-1]+$srchAntiSensePolyAOutterBound);
				}
				my $distFromCDSEnd = 0;
				foreach my $pos (@srchRng) {
					my $oppStrnd = $tmpOppStrndHsh{$mRNAStrnd};
					if ($clstrPeakByPosHsh_ref->{$cntg}{$pos}{$oppStrnd}) {
						my $clstrID = $clstrPeakByPosHsh_ref->{$cntg}{$pos}{$oppStrnd};
						if (not $tmpAssignedClstr{$clstrID}) {
							$mRNAHeadAntiSensePolyAInfoHsh_ref->{$mRNAID}{$clstrID}{'distFromCDSEnd'} = $distFromCDSEnd;
							$tmpAssignedClstr{$clstrID}++;
						}
					}
					$distFromCDSEnd--;
				}
			}
		}
		
		store($mRNAHeadAntiSensePolyAInfoHsh_ref, $mRNAHeadAntiSensePolyAInfoHshPlsPath);
	}

	my $mRNAWithPolyATail = keys %{$mRNAHeadAntiSensePolyAInfoHsh_ref};
	my $totalmRNANum = keys %{$mRNAInfoHsh_ref};
	my $pctWithPolyATail = sprintf "%.02f", 100*$mRNAWithPolyATail/$totalmRNANum;
	&printBothFHAndStdout("$mRNAWithPolyATail of $totalmRNANum [$pctWithPolyATail\%] mRNA were assigned with antisense polyA head", 10, $FH_paramValueLog);#->4176

	return ($mRNAHeadAntiSensePolyAInfoHsh_ref);
}
sub assignPolyAClusterTomRNABody {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: printBothFHAndStdout|4176, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 9_assignPolyAClustersToGenes|300
#	secondaryAppearInSection: >none
#	input: $FH_paramValueLog, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir
#	output: $mRNAGeneBodyPolyAInfoHsh_ref
#	toCall: my ($mRNAGeneBodyPolyAInfoHsh_ref) = &assignPolyAClusterTomRNABody($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $resultStorableDir, $FH_paramValueLog);
#	calledInLine: 314
#....................................................................................................................................................#
	my ($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $resultStorableDir, $FH_paramValueLog) = @_;
	
	my $mRNAGeneBodyPolyAInfoHsh_ref = {};
	my $mRNAGeneBodyPolyAInfoHshPlsPath = "$resultStorableDir/mRNAGeneBodyPolyAInfoHsh.pls";
	
	if (-s $mRNAGeneBodyPolyAInfoHshPlsPath) {

		&reportStatus("Retrieving mRNAGeneBodyPolyAInfoHsh", 20, "\n");#->4806
		$mRNAGeneBodyPolyAInfoHsh_ref = retrieve($mRNAGeneBodyPolyAInfoHshPlsPath);
		
	} else {
	
		&reportStatus("Assigning polyA clusters to mRNA gene body", 20, "\n");#->4806

		#---[04/10/2013 17:17] Set up a tmp hash for strand/dirtn conversion
		my %tmpDirtnHsh = ();
		$tmpDirtnHsh{'+'}{'s'} = '+';
		$tmpDirtnHsh{'+'}{'a'} = '-';
		$tmpDirtnHsh{'-'}{'s'} = '-';
		$tmpDirtnHsh{'-'}{'a'} = '+';

		#---[04/10/2013 16:50] Assign antisense polyA clstr to gene body and 
		foreach my $dirtn (qw/a s/) {
			my %tmpAssignedClstr = ();
			my $mRNAProc = 0;

			foreach my $cntg (keys %{$mRNAByCntgHsh_ref}) {
				foreach my $mRNAID (keys %{$mRNAByCntgHsh_ref->{$cntg}}) {
					$mRNAProc++;
					my $mRNAStrnd = $mRNAInfoHsh_ref->{$mRNAID}{'strnd'};
					&reportStatus("$mRNAProc mRNA processed", 30, "\r");#->4806
					my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
					my @srchRng = ($CDSRngAry[0]..$CDSRngAry[-1]);

					#---[05/10/2013 17:38] start from ATG if ‘s’, and start from TAA if ‘a’
					if (($mRNAStrnd eq '+' and $dirtn eq 'a')
					or 	($mRNAStrnd eq '-' and $dirtn eq 's')) {
						
						@srchRng = reverse @srchRng;
					}

					my $distFromCDSEnd = 0;
					foreach my $pos (@srchRng) {
						#---[04/10/2013 17:14] if there is a clster
						my $targetClstrStrnd = $tmpDirtnHsh{$mRNAStrnd}{$dirtn};
						if ($clstrPeakByPosHsh_ref->{$cntg}{$pos}{$targetClstrStrnd}) {
							my $clstrID = $clstrPeakByPosHsh_ref->{$cntg}{$pos}{$targetClstrStrnd};
							if (not $tmpAssignedClstr{$clstrID}) {
								$mRNAGeneBodyPolyAInfoHsh_ref->{$dirtn}{$mRNAID}{$clstrID}{'distFromCDSEnd'} = $distFromCDSEnd;
								$tmpAssignedClstr{$clstrID}++;
							}
						}
						if ($dirtn eq 'a') {
							$distFromCDSEnd--;
						} else {
							$distFromCDSEnd++;
						}
					}
				}
			}
		}
		store($mRNAGeneBodyPolyAInfoHsh_ref, $mRNAGeneBodyPolyAInfoHshPlsPath);
	}
	
	foreach my $dirtn (qw/a s/) {
		my $mRNAWithPolyATail = keys %{$mRNAGeneBodyPolyAInfoHsh_ref->{$dirtn}};
		my $totalmRNANum = keys %{$mRNAInfoHsh_ref};
		my $pctWithPolyATail = sprintf "%.02f", 100*$mRNAWithPolyATail/$totalmRNANum;
		&printBothFHAndStdout("$mRNAWithPolyATail of $totalmRNANum [$pctWithPolyATail\%] mRNA were assigned with $dirtn direction polyA clstr", 10, $FH_paramValueLog);#->4176
	}
	
	return ($mRNAGeneBodyPolyAInfoHsh_ref);
}
sub assignSensePolyAClusterTomRNATail {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: printBothFHAndStdout|4176, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 9_assignPolyAClustersToGenes|300
#	secondaryAppearInSection: >none
#	input: $FH_paramValueLog, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $controlPileupPlsPathHsh_ref, $jnctnByPosHsh_ref, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $maxCovGap, $resultStorableDir, $srchSensePolyAOutterBound
#	output: $mRNATailSensePolyAInfoHsh_ref
#	toCall: my ($mRNATailSensePolyAInfoHsh_ref) = &assignSensePolyAClusterTomRNATail($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $controlPileupPlsPathHsh_ref, $srchSensePolyAOutterBound, $maxCovGap, $jnctnByPosHsh_ref, $resultStorableDir, $FH_paramValueLog);
#	calledInLine: 313
#....................................................................................................................................................#
	my ($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $controlPileupPlsPathHsh_ref, $srchSensePolyAOutterBound, $maxCovGap, $jnctnByPosHsh_ref, $resultStorableDir, $FH_paramValueLog) = @_;

	my $minNonGapCov = 2;
	
	my $mRNATailSensePolyAInfoHsh_ref = {};
	my $mRNATailSensePolyAInfoHshPlsPath = "$resultStorableDir/mRNATailSensePolyAInfoHsh.pls";
	
	if (-s $mRNATailSensePolyAInfoHshPlsPath) {

		&reportStatus("Retrieving mRNATailSensePolyAInfoHsh", 20, "\n");#->4806
		$mRNATailSensePolyAInfoHsh_ref = retrieve($mRNATailSensePolyAInfoHshPlsPath);
		
	} else {

		&reportStatus("Assigning polyA clusters to mRNA", 20, "\n");#->4806
		my %tmpAssignedClstr = ();
		
		my $clusterAssigned = 0;
		my $mRNAProc = 0;
		foreach my $cntg (keys %{$mRNAByCntgHsh_ref}) {
			my $cntgCovAry_ref = retrieve($controlPileupPlsPathHsh_ref->{$cntg});

			#---expand the junction position
			my %jnctnExpandPosHsh = ();
			if ($jnctnByPosHsh_ref->{$cntg}) {
				foreach my $strnd (keys %{$jnctnByPosHsh_ref->{$cntg}}) {
					foreach (@{$jnctnByPosHsh_ref->{$cntg}{$strnd}}) {
						my ($intronStart, $intronEnd) = @{$_};
						$jnctnExpandPosHsh{$strnd}{$_}++ foreach ($intronStart..$intronEnd);
					}
				}
			}
		
			foreach my $mRNAID (keys %{$mRNAByCntgHsh_ref->{$cntg}}) {
				$mRNAProc++;
				&reportStatus("$mRNAProc mRNA processed", 30, "\r");#->4806
				my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
				my @srchRng = ();
				if ($mRNAInfoHsh_ref->{$mRNAID}{'strnd'} eq '+') {
					@srchRng = ($CDSRngAry[-1]+1..$CDSRngAry[-1]+$srchSensePolyAOutterBound+1);
				} else {
					@srchRng = reverse ($CDSRngAry[0]-$srchSensePolyAOutterBound..$CDSRngAry[0]-1);
				}
				my $covGap = 0;
				my $distFromCDSEnd = 0;
				foreach my $pos (@srchRng) {
					my $i = $pos -1;
					my %tmpCovHsh = ("+"=>0, "-"=>0);
					($tmpCovHsh{'+'}, $tmpCovHsh{'-'}) = split /,/, $cntgCovAry_ref->[$i] if $cntgCovAry_ref->[$i];
					#---if cov > minNonGapCov or within intron
					if ($tmpCovHsh{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}} >= $minNonGapCov or $jnctnExpandPosHsh{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}}{$i}) {
						$covGap = 0;
					} else {
						$covGap++;
					}
					last if $covGap > $maxCovGap; #---stop seaching if 
					if ($clstrPeakByPosHsh_ref->{$cntg}{$pos}{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}}) {
						$clusterAssigned++;
						my $clstrID = $clstrPeakByPosHsh_ref->{$cntg}{$pos}{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}};
						my $assigneClstr = 'no';
						
						if (not $tmpAssignedClstr{$clstrID}) {#---not assigned before
							$assigneClstr = 'yes';
	
						} else {#----already assigned to another gene, pick the one that is closer to the TAA
							if ($distFromCDSEnd < ${$tmpAssignedClstr{$clstrID}}[0]) { #----if the distance is closer
								$assigneClstr = 'yes';
								delete $mRNATailSensePolyAInfoHsh_ref->{${$tmpAssignedClstr{$clstrID}}[1]};
							}
						}
						
						if ($assigneClstr eq 'yes') {
							$mRNATailSensePolyAInfoHsh_ref->{$mRNAID}{$clstrID}{'covGap'} = $covGap;
							$mRNATailSensePolyAInfoHsh_ref->{$mRNAID}{$clstrID}{'distFromCDSEnd'} = $distFromCDSEnd;
							@{$tmpAssignedClstr{$clstrID}} = ($distFromCDSEnd, $mRNAID);
						}
					}
					$distFromCDSEnd++;
				}
			}
		}
		
		store($mRNATailSensePolyAInfoHsh_ref, $mRNATailSensePolyAInfoHshPlsPath);
	}

	my $mRNAWithPolyATail = keys %{$mRNATailSensePolyAInfoHsh_ref};
	my $totalmRNANum = keys %{$mRNAInfoHsh_ref};
	my $pctWithPolyATail = sprintf "%.02f", 100*$mRNAWithPolyATail/$totalmRNANum;
	&printBothFHAndStdout("$mRNAWithPolyATail of $totalmRNANum [$pctWithPolyATail\%] mRNA were assigned with sense polyA tail", 10, $FH_paramValueLog);#->4176

	return ($mRNATailSensePolyAInfoHsh_ref);
}
sub calculateBaseCompositionInAlignments {
#....................................................................................................................................................#
#	subroutineCategory: alignment, baseComposition
#	dependOnSub: reportStatus|4806
#	appearInSub: generateCleavageSiteWeblogoAndMotifFile|2400, plotBaseCompositionClstrPeak|3750
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	input: $seqAlignHsh_ref
#	output: $baseCompByBaseHsh_ref, $baseCompByPosHsh_ref, $baseCountByPosHsh_ref, $baseProportionHsh_ref
#	toCall: my ($baseCompByPosHsh_ref, $baseCompByBaseHsh_ref, $baseCountByPosHsh_ref, $baseProportionHsh_ref) = &calculateBaseCompositionInAlignments($seqAlignHsh_ref);
#	calledInLine: 2434, 3776
#....................................................................................................................................................#

	my ($seqAlignHsh_ref) = @_;
	
	my $baseCountByPosHsh_ref = {};
	my $baseCompByBaseHsh_ref = {};
	my $baseProportionHsh_ref = {};
	my $baseCompByPosHsh_ref = {};
	my $validSeqNum = 0;
	my $tmpLengthHsh_ref = {};
	my $totalBaseNum = 0;
	
	foreach my $seqName (keys %{$seqAlignHsh_ref}) {
		next if $seqAlignHsh_ref->{$seqName} =~ m/[^ATGCatgc]/;
		$validSeqNum++;
		my @seqAry = split //, $seqAlignHsh_ref->{$seqName};
		$tmpLengthHsh_ref->{@seqAry}++;
		for my $pos (0..$#seqAry) {
			my $base = $seqAry[$pos];
			$base =~ tr/atgc/ATGC/;
			$baseCountByPosHsh_ref->{$pos}{$base}++;
			$baseProportionHsh_ref->{$base}++;
			$totalBaseNum++;
		}
	}
	
	my $lengthNum = keys %{$tmpLengthHsh_ref};
	&reportStatus("WARNING: Length of the sequences in the alignment is not uniform", 10, "\n") if $lengthNum > 1;#->4806
	foreach my $base (qw/A T G C/) {
		foreach my $pos (sort {$a <=> $b} keys %{$baseCountByPosHsh_ref}) {
			$baseCountByPosHsh_ref->{$pos}{$base} = 0 if not $baseCountByPosHsh_ref->{$pos}{$base};
			$baseCompByBaseHsh_ref->{$base}{$pos} = $baseCountByPosHsh_ref->{$pos}{$base}/$validSeqNum;
			$baseCompByPosHsh_ref->{$pos}{$base} = $baseCountByPosHsh_ref->{$pos}{$base}/$validSeqNum;
		}
		
		$baseProportionHsh_ref->{$base} = 0 if not $baseProportionHsh_ref->{$base}++;
		$baseProportionHsh_ref->{$base} = $baseProportionHsh_ref->{$base}/$totalBaseNum;
	}
	
	return ($baseCompByPosHsh_ref, $baseCompByBaseHsh_ref, $baseCountByPosHsh_ref, $baseProportionHsh_ref);
	
}
sub calculatePolyAOccurenceWithinCDSOnBothStrand {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: ggplotXYLinesMultipleSamples|3622, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 10_gatherAndReportPolyAInfo|320
#	secondaryAppearInSection: >none
#	input: $ggplotDirHsh_ref, $mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $minCDSLenPolyOccurencePlot, $resultLogDir
#	output: 
#	toCall: &calculatePolyAOccurenceWithinCDSOnBothStrand($mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $minCDSLenPolyOccurencePlot, $resultLogDir, $ggplotDirHsh_ref);
#	calledInLine: 328
#....................................................................................................................................................#
	my ($mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $minCDSLenPolyOccurencePlot, $resultLogDir, $ggplotDirHsh_ref) = @_;
	
	my $numGene = 0;
	my $bin = 5;
	my %tmpPACCountHsh = ();
	&reportStatus("Calculating PolyAOccurence Within CDS On Both Strand", 10, "\n");#->4806
	foreach my $mRNAID (keys %{$mRNAInfoHsh_ref}) {
		@{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}} = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
		my ($CDSStart, $CDSEnd) = (${$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}}[0], ${$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}}[-1]);
		my $CDSLength = $CDSEnd - $CDSStart;
		
		#---[09/10/2013 15:32] only take genes > $minCDSLenPolyOccurencePlot;
		if ($CDSLength >= $minCDSLenPolyOccurencePlot) {
			$numGene++;
			foreach my $dirtn (qw/a s/) {
				my $rltvPosStr = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{'body'}{$mRNAID}{'rltvPosStr'};
				if ($rltvPosStr ne 'none') {
					my @rltvPosAry = split ";", $rltvPosStr;
					foreach my $rltvPos (@rltvPosAry) {
						my $distanceFromStartOrStopCodon = abs($rltvPos);
						#---[09/10/2013 15:32] take only the position with minCDSLenPolyOccurencePlot
						if ($distanceFromStartOrStopCodon <= $minCDSLenPolyOccurencePlot) {
							my $binDistance  = nearest($bin, $distanceFromStartOrStopCodon);
							$tmpPACCountHsh{$dirtn}{$binDistance}++;
						}
					}
				}
			}
		}
	}
	&reportStatus("Plotting PolyAOccurence Within CDS On Both Strand", 10, "\n");#->4806
	my $PACOccurenceHsh_ref = {};
	foreach my $dirtn (keys %tmpPACCountHsh) {
		for (my $binDistance = 0; $binDistance <= $minCDSLenPolyOccurencePlot; $binDistance += $bin) {
			$PACOccurenceHsh_ref->{$dirtn}{$binDistance} = 0;
			$PACOccurenceHsh_ref->{$dirtn}{$binDistance} = sprintf "%.10f", $tmpPACCountHsh{$dirtn}{$binDistance}/$numGene if $tmpPACCountHsh{$dirtn}{$binDistance};
		}
	}

	my $sub_ggplotDir = "PACOccurenceOnBothStrand";
	system "mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$sub_ggplotDir/" foreach (keys %{$ggplotDirHsh_ref});
	
	{	
		my $title = "N=$numGene";
		my $item = 'PACOccurenceWithinCDS';
		my $plotDataHsh_ref = $PACOccurenceHsh_ref;
		my $dataPath = "$ggplotDirHsh_ref->{'dat'}/$sub_ggplotDir/$item.dat";
		my $pdfPath = "$ggplotDirHsh_ref->{'pdf'}/$sub_ggplotDir/$item.pdf";
		my $RScriptPath = "$ggplotDirHsh_ref->{'R'}/$sub_ggplotDir/$item.R";
		my $logPath = "$ggplotDirHsh_ref->{'log'}/$sub_ggplotDir/$item.log";
		my $XAXis = 'distanceFromStartOrStopCodon';
		my $YAxis = 'number_Of_PAC_per_gene_per_site';
		my $YVariable = 'strand';
		my $extraArg = " + ggtitle (\"$title\")+ scale_x_continuous(breaks=seq(0, $minCDSLenPolyOccurencePlot, by=100))";
		my $height = 8;
		my $width = 10;
		&ggplotXYLinesMultipleSamples($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $YVariable, $extraArg, $height, $width);#->3622
	}
	
	return ();
}
sub categorizePolyAClstrForDreme {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: dremePolyASiteMotif|2040
#	appearInSub: >none
#	primaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	secondaryAppearInSection: >none
#	input: $cleavageSiteSeqPosHsh_ref, $clstrBasedPolyAInfoHsh_ref, $clstrInfoHsh_ref, $clstrSeqRng, $resultDremeDir
#	output: $cleavageSiteSeqHsh_ref, $clstrSeqHsh_ref, $polyADremePathHsh_ref
#	toCall: my ($polyADremePathHsh_ref, $clstrSeqHsh_ref, $cleavageSiteSeqHsh_ref) = &categorizePolyAClstrForDreme($clstrInfoHsh_ref, $clstrBasedPolyAInfoHsh_ref, $clstrSeqRng, $resultDremeDir, $cleavageSiteSeqPosHsh_ref);
#	calledInLine: 338
#....................................................................................................................................................#
	my ($clstrInfoHsh_ref, $clstrBasedPolyAInfoHsh_ref, $clstrSeqRng, $resultDremeDir, $cleavageSiteSeqPosHsh_ref) = @_;
	
	my $minPeakRdNum = 3;
	my $peakClstrOnly = 'yes';
	
	#---[07/10/2013 18:25] define the regions
	my $regionInfoHsh_ref = {};


	my $dremeParamHsh_ref = {};
	$regionInfoHsh_ref->{'PAS'}{'pos'} = [qw/-25 -10/]; #----target region: -ve for upstream, +ve for down stream, 0 is the 1st base after cleavage;
	$regionInfoHsh_ref->{'PAS'}{'neg'} = [qw/-100 -85/]; #----control region: -ve for upstream, +ve for down stream, 0 is the 1st base after cleavage;
	$dremeParamHsh_ref->{'PAS'}{'maxk'} = 6;
	$dremeParamHsh_ref->{'PAS'}{'mink'} = 6;
	$dremeParamHsh_ref->{'PAS'}{'minE'} = 0.1;
	$dremeParamHsh_ref->{'PAS'}{'dremeMode'} = 'both';

	$regionInfoHsh_ref->{'DSE'}{'pos'} = [qw/0 35/]; #----target region: -ve for upstream, +ve for down stream, 0 is the 1st base after cleavage;
	$regionInfoHsh_ref->{'DSE'}{'neg'} = [qw/-100 -65/]; #----control region: -ve for upstream, +ve for down stream, 0 is the 1st base after cleavage;
	$dremeParamHsh_ref->{'DSE'}{'maxk'} = 6;
	$dremeParamHsh_ref->{'DSE'}{'mink'} = 6;
	$dremeParamHsh_ref->{'DSE'}{'minE'} = 0.1;
	$dremeParamHsh_ref->{'DSE'}{'dremeMode'} = 'both';

	#---[07/10/2013 18:25] define the clstrType
	my $clstrSeqHsh_ref = {};
	my $clstrIDFiltrHsh_ref = {};
	my $cleavageSiteSeqHsh_ref = {};
	
	foreach my $clstrID (keys %{$clstrInfoHsh_ref}) {
		
		#---skip clstr with incomplete sequence
		next if length($clstrInfoHsh_ref->{$clstrID}{'upStrmSeq'}) != $clstrSeqRng;
		next if length($clstrInfoHsh_ref->{$clstrID}{'dnStrmSeq'}) != $clstrSeqRng;

			#---[07/10/2013 18:37] get only the clstr with >= minPeakRdNum
		next if ($clstrInfoHsh_ref->{$clstrID}{'peakRdNum'} < $minPeakRdNum);

		#---[07/10/2013 18:46] get only the cltsrID that is assigned to polyAType
		if ($clstrBasedPolyAInfoHsh_ref->{$clstrID}) {
			my $polyATypeNum = keys %{$clstrBasedPolyAInfoHsh_ref->{$clstrID}};
			if ($polyATypeNum == 1) {
				foreach my $polyATypeTag (keys %{$clstrBasedPolyAInfoHsh_ref->{$clstrID}}) {
					#---[07/10/2013 18:34] will take peak polyA clister only
					next if ($peakClstrOnly eq 'yes' and $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'peak'} eq 'no');
					$clstrIDFiltrHsh_ref->{$polyATypeTag}{$clstrID}++;
					$clstrSeqHsh_ref->{$polyATypeTag}{$clstrID} = $clstrInfoHsh_ref->{$clstrID}{'upStrmSeq'}.$clstrInfoHsh_ref->{$clstrID}{'dnStrmSeq'};
					my $upStrmCleavageSiteSeq = substr $clstrInfoHsh_ref->{$clstrID}{'upStrmSeq'}, $cleavageSiteSeqPosHsh_ref->{'upStrmStart'};
					my $dnStrmCleavageSiteSeq = substr $clstrInfoHsh_ref->{$clstrID}{'dnStrmSeq'}, 0, $cleavageSiteSeqPosHsh_ref->{'dnStrmEnd'};
					$cleavageSiteSeqHsh_ref->{$polyATypeTag}{$clstrID} = $upStrmCleavageSiteSeq.$dnStrmCleavageSiteSeq;
				}
			}
		}
	}
	
	my ($polyADremePathHsh_ref) = &dremePolyASiteMotif($clstrInfoHsh_ref, $clstrIDFiltrHsh_ref, $clstrSeqRng, $regionInfoHsh_ref, $resultDremeDir, $dremeParamHsh_ref);#->2040

	return ($polyADremePathHsh_ref, $clstrSeqHsh_ref, $cleavageSiteSeqHsh_ref);
}
sub checkGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: general, gff
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref
#	output: 
#	toCall: &checkGeneInfo($geneInfoHsh_ref);
#	calledInLine: 218
#....................................................................................................................................................#
	
	my ($geneInfoHsh_ref) = @_;
	
	&reportStatus("Checking gene categories", 0, "\n");#->4806
	my $ctrgyCountHsh_ref = {};
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my $ctgry = $geneInfoHsh_ref->{$geneID}{'ctgry'};
		$ctrgyCountHsh_ref->{$ctgry}++;
	}
	
	foreach my $ctgry (sort keys %{$ctrgyCountHsh_ref}) {
		&reportStatus("Item in $ctgry = $ctrgyCountHsh_ref->{$ctgry}", 0, "\n");#->4806
	}
	
	return ();
}
sub checkOverlapAndProximity {
#....................................................................................................................................................#
#	subroutineCategory: range
#	dependOnSub: currentTime|1872, generateThreadHshWithRandomCntg|2558, reportStatus|4806
#	appearInSub: checkmRNAProximity|1255
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 4_processGenomeInformation|209
#	input: $checkPrxmty, $maxThread, $qryInfoHsh_ref, $qryRngType, $refInfoHsh_ref, $refRngType, $reportExactMatch
#	output: $hitAndPrxmtyByQryHsh_ref, $hitAndPrxmtyByRefHsh_ref
#	toCall: my ($hitAndPrxmtyByRefHsh_ref, $hitAndPrxmtyByQryHsh_ref) = &checkOverlapAndProximity($refInfoHsh_ref, $qryInfoHsh_ref, $checkPrxmty, $reportExactMatch, $maxThread, $refRngType, $qryRngType);
#	calledInLine: 1279
#....................................................................................................................................................#
	#---incoming variables
	my ($refInfoHsh_ref, $qryInfoHsh_ref, $checkPrxmty, $reportExactMatch, $maxThread, $refRngType, $qryRngType) = @_;

	#---outgoing variables
	my $refGeneNumTotal = 0;
	
	#---make a tmpHsh to contain all cntgs the have either ref and qry
	my $tmpCntgHsh_ref = {};
	my $refCntgHsh_ref = {};
	my $qryCntgHsh_ref = {};
	
	foreach my $geneID (keys %{$refInfoHsh_ref}) {
		my $cntg = $refInfoHsh_ref->{$geneID}{'cntg'};
		$refGeneNumTotal++;
		$tmpCntgHsh_ref->{$cntg}++;
		$refCntgHsh_ref->{$cntg}{$geneID}++;
	}
	
	foreach my $geneID (keys %{$qryInfoHsh_ref}) {
		my $cntg = $qryInfoHsh_ref->{$geneID}{'cntg'};
		$tmpCntgHsh_ref->{$cntg}++;
		$qryCntgHsh_ref->{$cntg}{$geneID}++;
	}
	
	my $totalCntgNum = keys %{$tmpCntgHsh_ref};
	my @cntgAry = keys %{$tmpCntgHsh_ref};

	my ($randCntgInThreadHsh_ref) = &generateThreadHshWithRandomCntg($maxThread, \@cntgAry);#->2558
	my $refGeneNumProc :shared = 0;
	my %threadHsh = ();

	foreach my $threadNum (sort {$a <=> $b} keys %{$randCntgInThreadHsh_ref}) {
		my $cntgAry_ref = \@{$randCntgInThreadHsh_ref->{$threadNum}};
		my $cntgNum = @{$randCntgInThreadHsh_ref->{$threadNum}};
		&reportStatus("$cntgNum cntgs spawned to thread $threadNum", 20, "\n");#->4806

		#---spawn a new thread
		($threadHsh{$threadNum}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781
		
			sub {
				my ($cntgAry_ref) = @_;
	
				my $hitAndPrxmtyByRefHsh_InThr_ref = {};
				my $hitAndPrxmtyByQryHsh_InThr_ref = {};

				foreach my $cntg (@{$cntgAry_ref}) {

					#---update the on-screen progress
					#&reportStatus("Finding overlaping on $cntg", 20, "\r");#->4806
		
					my $tmpPrxmtyByRefHsh_ref = {};
					my $tmpPrxmtyByQryHsh_ref = {};

					if ((exists $qryCntgHsh_ref->{$cntg}) and (exists $refCntgHsh_ref->{$cntg})) {#---if there are both ref and qry can both be found on cntg
						foreach my $refGeneID (keys %{$refCntgHsh_ref->{$cntg}}) {#--- all ftur on the $strnd of $cntg of refGff
							next if not $refInfoHsh_ref->{$refGeneID}{$refRngType};
							my ($refStart, $refEnd) = @{$refInfoHsh_ref->{$refGeneID}{$refRngType}};
				
							$refGeneNumProc++;
				
							&reportStatus("$refGeneNumProc of $refGeneNumTotal reference genes checked", 20, "\r");#->4806

							foreach my $qryGeneID (keys %{$qryCntgHsh_ref->{$cntg}}) {#--- all ftur on the $strnd of $cntg of QryGtf
								next if not $qryInfoHsh_ref->{$qryGeneID}{$qryRngType};
	
								my $samestrnd = "no";
								$samestrnd = "yes" if ($refInfoHsh_ref->{$refGeneID}{'strnd'} eq $qryInfoHsh_ref->{$qryGeneID}{'strnd'});
								my ($qryStart, $qryEnd) = @{$qryInfoHsh_ref->{$qryGeneID}{$qryRngType}};

								my $scene;
								my $ovrlpSize;

								if (($refStart == $qryStart) && ($refEnd == $qryEnd)) {#---scene 0
									$scene = 'exactMatch';
									$ovrlpSize = $qryEnd - $qryStart;
						
								} elsif (($refStart<=$qryStart)&&($refEnd>=$qryStart)&&($refEnd<=$qryEnd)) {#---scene 1
									$scene = 'overlapTail';
									$ovrlpSize = $refEnd - $qryStart;

								} elsif (($refStart>=$qryStart)&&($refStart<=$qryEnd)&&($refEnd>=$qryEnd)) {#---scene 2
									$scene = 'overlapHead';
									$ovrlpSize = $qryEnd - $refStart;

								} elsif (($refStart<=$qryStart)&&($refEnd>=$qryEnd)) {#---scene 3
									$scene = 'cover';
									$ovrlpSize = $qryEnd - $qryStart;

								} elsif (($refStart>=$qryStart)&&($refEnd<=$qryEnd)) {#---scene 4
									$scene = 'within';
									$ovrlpSize = $refEnd - $refStart;

								#------Proximity with ref's tail proximal to qry's head
								} elsif (($refEnd<=$qryStart)&&($refEnd<$qryEnd)) {#---scene 5 ---> ref Tail, qry Head

									$scene = 'prxmtyTail';

									if ($checkPrxmty eq "yes") {
										my $tmpPrmxty = $qryStart - $refEnd;
										$tmpPrxmtyByRefHsh_ref->{'XS'}{$refGeneID}{"T"}{$qryGeneID} = $tmpPrmxty;
										$tmpPrxmtyByQryHsh_ref->{'XS'}{$qryGeneID}{"H"}{$refGeneID} = $tmpPrmxty;

										if ($samestrnd eq "yes") {
											$tmpPrxmtyByRefHsh_ref->{'SS'}{$refGeneID}{"T"}{$qryGeneID} = $tmpPrmxty;
											$tmpPrxmtyByQryHsh_ref->{'SS'}{$qryGeneID}{"H"}{$refGeneID} = $tmpPrmxty;
										}
									}

								#------Proximity with ref's head proximal to qry's tail
								} elsif (($refStart>=$qryEnd)&&($refStart>$qryStart)) {#---scene 6 ---> ref Head, qry Tail

									$scene = 'prxmtyHead';

									if ($checkPrxmty eq "yes") {
										my $tmpPrmxty = $refStart - $qryEnd;
										$tmpPrxmtyByRefHsh_ref->{'XS'}{$refGeneID}{"H"}{$qryGeneID} = $tmpPrmxty;
										$tmpPrxmtyByQryHsh_ref->{'XS'}{$qryGeneID}{"T"}{$refGeneID} = $tmpPrmxty;

										if ($samestrnd eq "yes") {
											$tmpPrxmtyByRefHsh_ref->{'SS'}{$refGeneID}{"H"}{$qryGeneID} = $tmpPrmxty;
											$tmpPrxmtyByQryHsh_ref->{'SS'}{$qryGeneID}{"T"}{$refGeneID} = $tmpPrmxty;
										}
									}

								} else {#---BUG! possibly other scene?
									#print "[".&currentTime()."] refStart=$refStart; refEnd=$refEnd; qryStart=$qryStart; qryEnd=$qryEnd\n";#->1872
									die "Unexpected overlapping scene between $refGeneID and $qryGeneID. It's a Bug. Program qutting.\n";
								}
					
								if ($scene ne 'prxmtyTail' and $scene ne 'prxmtyHead' and not ($reportExactMatch eq 'no' and $scene eq 'exactMatch')) {

									@{$hitAndPrxmtyByRefHsh_InThr_ref->{'XS'}{'hit'}{$refGeneID}{$qryGeneID}} = ($scene, $ovrlpSize);
									@{$hitAndPrxmtyByQryHsh_InThr_ref->{'XS'}{'hit'}{$qryGeneID}{$refGeneID}} = ($scene, $ovrlpSize);

									if ($samestrnd eq "yes") {
										@{$hitAndPrxmtyByRefHsh_InThr_ref->{'SS'}{'hit'}{$refGeneID}{$qryGeneID}} = ($scene, $ovrlpSize);
										@{$hitAndPrxmtyByQryHsh_InThr_ref->{'SS'}{'hit'}{$qryGeneID}{$refGeneID}} = ($scene, $ovrlpSize);
									}
								}
							}
						}
					}

					#---find the closest proximity for all refs
					if ($checkPrxmty eq "yes") {
						my $refQryRefHsh_ref = {};

						$refQryRefHsh_ref->{'ref'}{'tmpPrxmtyHsh_ref'} = $tmpPrxmtyByRefHsh_ref;
						$refQryRefHsh_ref->{'ref'}{'cntgHsh_ref'} = $refCntgHsh_ref;
						$refQryRefHsh_ref->{'ref'}{'hitAndPrxmtyHsh_ref'} = $hitAndPrxmtyByRefHsh_InThr_ref;

						$refQryRefHsh_ref->{'qry'}{'tmpPrxmtyHsh_ref'} = $tmpPrxmtyByQryHsh_ref;
						$refQryRefHsh_ref->{'qry'}{'cntgHsh_ref'} = $qryCntgHsh_ref;
						$refQryRefHsh_ref->{'qry'}{'hitAndPrxmtyHsh_ref'} = $hitAndPrxmtyByQryHsh_InThr_ref;
			
						my %tmpInfoHshRefHsh = ('ref'=>$refInfoHsh_ref, 'qry'=>$qryInfoHsh_ref);
						
						foreach my $refOrQry ('ref', 'qry') {

							my $cntgHsh_ref = $refQryRefHsh_ref->{$refOrQry}{'cntgHsh_ref'};
							my $tmpPrxmtyHsh_ref = $refQryRefHsh_ref->{$refOrQry}{'tmpPrxmtyHsh_ref'};
							my $hitAndPrxmtyHsh_ref = $refQryRefHsh_ref->{$refOrQry}{'hitAndPrxmtyHsh_ref'};

							foreach my $ftur (keys %{$cntgHsh_ref->{$cntg}}) {
								foreach my $XSOrSS ('XS', 'SS') {
									foreach my $HOrT ('H', 'T') {
										$tmpPrxmtyHsh_ref->{$XSOrSS}{$ftur}{$HOrT}{"edge"} = -999 if (not exists $tmpPrxmtyHsh_ref->{$XSOrSS}{$ftur}{$HOrT});
										foreach my $otherFtur (sort {$tmpPrxmtyHsh_ref->{$XSOrSS}{$ftur}{$HOrT}{$a} <=> $tmpPrxmtyHsh_ref->{$XSOrSS}{$ftur}{$HOrT}{$b}} keys %{$tmpPrxmtyHsh_ref->{$XSOrSS}{$ftur}{$HOrT}}) {
											@{$hitAndPrxmtyHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{$HOrT}} = ($tmpPrxmtyHsh_ref->{$XSOrSS}{$ftur}{$HOrT}{$otherFtur}, $otherFtur);
											last; #---sample the smallest only
										}
									}
									#---reverse H and T if strnd is -
									if ($tmpInfoHshRefHsh{$refOrQry}->{$ftur}{'strnd'} eq '-') {
										($hitAndPrxmtyHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{'H'}, $hitAndPrxmtyHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{'T'}) = ($hitAndPrxmtyHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{'T'}, $hitAndPrxmtyHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{'H'});
									}
								}
							}
						}
					}
				}
				
				return ($hitAndPrxmtyByRefHsh_InThr_ref, $hitAndPrxmtyByQryHsh_InThr_ref);
			}
			,($cntgAry_ref)
		);
	}
	
	my %tmpTransferThrDataHsh = ();
	$tmpTransferThrDataHsh{'ref'}{'all'} = {};
	$tmpTransferThrDataHsh{'qry'}{'all'} = {};
	
	while (keys %threadHsh) {
		foreach my $threadNum (keys %threadHsh) {
			my $thr = $threadHsh{$threadNum};
			if (not $thr->is_running()) {
				($tmpTransferThrDataHsh{'ref'}{'thr'}, $tmpTransferThrDataHsh{'qry'}{'thr'}) = $thr->join;
				foreach my $refOrQry (keys %tmpTransferThrDataHsh) {
					my ($allHsh_ref, $thrHsh_ref) = ($tmpTransferThrDataHsh{$refOrQry}{'all'}, $tmpTransferThrDataHsh{$refOrQry}{'thr'});
					foreach my $XSOrSS ('XS', 'SS') {
						foreach my $ftur (keys %{$thrHsh_ref->{$XSOrSS}{'hit'}}) {
							foreach my $hitftur (keys %{$thrHsh_ref->{$XSOrSS}{'hit'}{$ftur}}) {
								@{$allHsh_ref->{$XSOrSS}{'hit'}{$ftur}{$hitftur}} = @{$thrHsh_ref->{$XSOrSS}{'hit'}{$ftur}{$hitftur}};
							}
						}
						
						if ($thrHsh_ref->{$XSOrSS}{'prxmty'}) {
							foreach my $ftur (keys %{$thrHsh_ref->{$XSOrSS}{'prxmty'}}) {
								foreach my $HOrT (keys %{$thrHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}}) {
									@{$allHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{$HOrT}} = @{$thrHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{$HOrT}} if $thrHsh_ref->{$XSOrSS}{'prxmty'}{$ftur}{$HOrT};
								}
							}
						}
					}
				}
				delete $threadHsh{$threadNum};
			}
		}
		sleep 1;
	}

	print "\n";

	my $hitAndPrxmtyByRefHsh_ref = $tmpTransferThrDataHsh{'ref'}{'all'};
	my $hitAndPrxmtyByQryHsh_ref = $tmpTransferThrDataHsh{'qry'}{'all'};

	return ($hitAndPrxmtyByRefHsh_ref, $hitAndPrxmtyByQryHsh_ref);
}
sub checkRunningThreadAndWaitToJoin {
#....................................................................................................................................................#
#	subroutineCategory: multithread
#	dependOnSub: reportStatus|4806
#	appearInSub: countMotifOccurenceInCDSWithShortAndLongCisNAT|1642, dremeATGssTAAasMotif|1979, printWigFromCovPerlStorable|4474
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $sleepTime, $verbose
#	output: none
#	toCall: &checkRunningThreadAndWaitToJoin($verbose, $sleepTime);
#	calledInLine: 1765, 2035, 4530
#....................................................................................................................................................#
	
	my ($verbose, $sleepTime) = @_;
	
	my @runningThrAry = threads->list(threads::running);
	my @joinableThrAry = threads->list(threads::joinable);
	while (@runningThrAry or @joinableThrAry) {
		@runningThrAry = threads->list(threads::running);
		@joinableThrAry = threads->list(threads::joinable);
		foreach my $joinableThr (@joinableThrAry) {
			$joinableThr->detach() if not $joinableThr->is_running();
		}
		my $numThreadRunning = scalar @runningThrAry;
		&reportStatus("The last $numThreadRunning threads are still running", 20, "\r") if $verbose eq 'yes';#->4806
		sleep $sleepTime;
	}
}
sub checkmRNAProximity {
#....................................................................................................................................................#
#	subroutineCategory: range
#	dependOnSub: checkOverlapAndProximity|987, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $mRNAInfoHsh_ref, $maxThread, $resultStorableDir
#	output: $hitAndPrxmtyBymRNAHsh_ref
#	toCall: my ($hitAndPrxmtyBymRNAHsh_ref) = &checkmRNAProximity($resultStorableDir, $geneInfoHsh_ref, $mRNAInfoHsh_ref, $maxThread);
#	calledInLine: 220
#....................................................................................................................................................#
	my ($resultStorableDir, $geneInfoHsh_ref, $mRNAInfoHsh_ref, $maxThread) = @_;
	
	my $hitAndPrxmtyBymRNAHsh_ref = {};
	my $hitAndPrxmtyBymRNAHshPlsPath = "$resultStorableDir/hitAndPrxmtyBymRNAHsh.pls";
	if (-s $hitAndPrxmtyBymRNAHshPlsPath) {
		&reportStatus("Retrieving hitAndPrxmtyBymRNAHsh", 0,"\n");#->4806
		$hitAndPrxmtyBymRNAHsh_ref = retrieve($hitAndPrxmtyBymRNAHshPlsPath);
	} else {
		&reportStatus("Finding mRNA proximity", 0,"\n");#->4806
		my $checkPrxmty = 'yes';
		my $reportExactMatch = 'no';
		my $refRngType = 'CDSRng';
		my $qryRngType = 'CDSRng';
		($hitAndPrxmtyBymRNAHsh_ref, undef) = &checkOverlapAndProximity($mRNAInfoHsh_ref, $geneInfoHsh_ref, $checkPrxmty, $reportExactMatch, $maxThread, $refRngType, $qryRngType);#->987
		store($hitAndPrxmtyBymRNAHsh_ref, $hitAndPrxmtyBymRNAHshPlsPath);
	}

	return ($hitAndPrxmtyBymRNAHsh_ref);
}
sub classifymRNABasedOnProximity {
#....................................................................................................................................................#
#	subroutineCategory: range
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $maxPrxmty, $minPrxmty
#	output: $mRNAPrxmtyClassListHsh_ref
#	toCall: my ($mRNAPrxmtyClassListHsh_ref) = &classifymRNABasedOnProximity($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $minPrxmty, $maxPrxmty);
#	calledInLine: 236
#....................................................................................................................................................#
	my ($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $minPrxmty, $maxPrxmty) = @_;
	
	#---set default valuea
	$minPrxmty = 50 if not $minPrxmty;
	$maxPrxmty = 500 if not $maxPrxmty;
	
	&reportStatus("Classifying mRNAs based on proximity mRNA", 20,"\n");#->4806
	
	my %tmpHeadTailHsh = ('H'=>'head', 'T'=>'tail');
	
	my $mRNAPrxmtyClassListHsh_ref = {};
	foreach my $mRNAID (keys %{$mRNAInfoHsh_ref}) {
		
		#--exclude any gene that is overlapping with anything
		next if ($hitAndPrxmtyBymRNAHsh_ref->{'XS'}{'hit'}{$mRNAID});
		
		foreach my $HOrT (keys %{$hitAndPrxmtyBymRNAHsh_ref->{'XS'}{'prxmty'}{$mRNAID}}) {
			my ($prxmtyDist, $prxmtyID) = @{$hitAndPrxmtyBymRNAHsh_ref->{'XS'}{'prxmty'}{$mRNAID}{$HOrT}};
			next if not $mRNAInfoHsh_ref->{$prxmtyID}; #---skip if the proximal feature is not a mRNA
			my $dirtn = 's';
			$dirtn = 'a' if $mRNAInfoHsh_ref->{$mRNAID}{'strnd'} ne $mRNAInfoHsh_ref->{$prxmtyID}{'strnd'};
			if ($prxmtyDist >= $minPrxmty and $prxmtyDist <= $maxPrxmty) {
				$mRNAPrxmtyClassListHsh_ref->{$tmpHeadTailHsh{$HOrT}}{$dirtn}{$mRNAID}++;
			}
		}
	}
	
	foreach my $headOrTail (keys %{$mRNAPrxmtyClassListHsh_ref}) {
		foreach my $dirtn (keys %{$mRNAPrxmtyClassListHsh_ref->{$headOrTail}}) {
			my $numGene = keys %{$mRNAPrxmtyClassListHsh_ref->{$headOrTail}{$dirtn}};
			&reportStatus("prxmty $headOrTail in dirtn $dirtn = $numGene", 20,"\n");#->4806
		}
	}

	return ($mRNAPrxmtyClassListHsh_ref);
}
sub clusterPolyASites {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: generateThreadHshWithRandomCntg|2558, reportStatus|4806
#	appearInSub: optimizeGapSizeAndClstrPolyASites|3657
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 8_findOptimalGapSizeAndClusterPolyASites|290
#	input: $getFullInfo, $maxGapInClstr, $maxThread, $polyATailLenPlsPathHsh_ref, $validPolyASitePlsPathHsh_ref
#	output: $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $clstrStatHsh_ref
#	toCall: my ($clstrInfoHsh_ref, $clstrStatHsh_ref, $clstrPeakByPosHsh_ref) = &clusterPolyASites($validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $maxGapInClstr, $maxThread, $getFullInfo);
#	calledInLine: 3699, 3742
#....................................................................................................................................................#
	my ($validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $maxGapInClstr, $maxThread, $getFullInfo) = @_;
	
	my @cntgAry = keys %{$validPolyASitePlsPathHsh_ref};
	my ($randCntgInThreadHsh_ref) = &generateThreadHshWithRandomCntg($maxThread, \@cntgAry);#->2558
	my $cntgProc :shared = 0;
	my %threadHsh = ();

	foreach my $threadNum (sort {$a <=> $b} keys %{$randCntgInThreadHsh_ref}) {
		my $cntgAry_ref = \@{$randCntgInThreadHsh_ref->{$threadNum}};
		my $cntgNum = @{$randCntgInThreadHsh_ref->{$threadNum}};

		#---spawn a new thread
		($threadHsh{$threadNum}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781
		
			sub {
				my ($cntgAry_ref) = @_;

				my $clstrInfoHsh_inThr_ref = {};
				foreach my $cntg (@{$cntgAry_ref}) {
					$cntgProc++;
					&reportStatus("$cntgProc cntg processed", 40, "\r");#->4806
					my $clstrNum = 0;
					my $cntgRdNumAry_ref = retrieve($validPolyASitePlsPathHsh_ref->{$cntg});
					my $cntgALenAry_ref = {};
					$cntgALenAry_ref = retrieve($polyATailLenPlsPathHsh_ref->{$cntg}) if $getFullInfo eq 'yes';
					my %gapSizeHsh = ('+'=>0, '-'=>0);
					for my $i (0..$#{$cntgRdNumAry_ref}) {

						my %tmpRdNumHsh = ('+'=>0, '-'=>0);
						($tmpRdNumHsh{'+'}, $tmpRdNumHsh{'-'}) = split ",", $cntgRdNumAry_ref->[$i] if $cntgRdNumAry_ref->[$i];
						
						my %tmpALenHsh = ();
						if ($getFullInfo eq 'yes') {
							%tmpALenHsh = ('+'=>0, '-'=>0);
							($tmpALenHsh{'+'}, $tmpALenHsh{'-'}) = split ",", $cntgALenAry_ref->[$i] if $cntgALenAry_ref->[$i];
						}

						foreach my $strnd (qw/+ -/) {
							if ($tmpRdNumHsh{$strnd} > 0) {
								$clstrNum++ if $gapSizeHsh{$strnd} >= $maxGapInClstr;
								my $clstrID = join "_", ($cntg, $clstrNum, $strnd);
								$clstrInfoHsh_inThr_ref->{$clstrID}{'siteNum'}++;
								if ($getFullInfo eq 'yes') {
									$clstrInfoHsh_inThr_ref->{$clstrID}{'cntg'} = $cntg;
									$clstrInfoHsh_inThr_ref->{$clstrID}{'strnd'} = $strnd;
									push @{$clstrInfoHsh_inThr_ref->{$clstrID}{'pos'}}, $i+1;
									push @{$clstrInfoHsh_inThr_ref->{$clstrID}{'rdNum'}}, $tmpRdNumHsh{$strnd};
									push @{$clstrInfoHsh_inThr_ref->{$clstrID}{'ALen'}}, $tmpALenHsh{$strnd};
								}
								
								$gapSizeHsh{$strnd} = 0;
							} else {
								$gapSizeHsh{$strnd}++;
							}
						}
					}
				}
				return ($clstrInfoHsh_inThr_ref);
			}
			,($cntgAry_ref)
		);
	}
	
	my $clstrInfoHsh_ref = {};
	my $clstrPeakByPosHsh_ref = {};
	
	my $clstrStatHsh_ref = {};
	$clstrStatHsh_ref->{'totalNum'} = 0;
	$clstrStatHsh_ref->{'orphanNum'} = 0;
	$clstrStatHsh_ref->{'orphanPct'} = 0;
	$clstrStatHsh_ref->{'inClstrNum'} = 0;
	$clstrStatHsh_ref->{'inClstrPct'} = 0;
	
	while (keys %threadHsh) {
		foreach my $threadNum (keys %threadHsh) {
			my $thr = $threadHsh{$threadNum};
			if (not $thr->is_running()) {
				my ($clstrInfoHsh_inThr_ref) = $thr->join;
				foreach my $clstrID (keys %{$clstrInfoHsh_inThr_ref}) {
					my $siteNum = $clstrInfoHsh_inThr_ref->{$clstrID}{'siteNum'};

					#---get the peak value if getFullInfo
					if ($getFullInfo eq 'yes') {
						my $stat = Statistics::Descriptive::Full->new();
						$stat->add_data(@{$clstrInfoHsh_inThr_ref->{$clstrID}{'rdNum'}});
						my $maxdex = $stat->maxdex();
						my @sortedPos = sort {$a <=> $b} @{$clstrInfoHsh_inThr_ref->{$clstrID}{'pos'}};
						my $clstrSize = $sortedPos[-1] - $sortedPos[0] +1;
						$clstrInfoHsh_inThr_ref->{$clstrID}{'clstrSize'} = $clstrSize;
						$clstrInfoHsh_inThr_ref->{$clstrID}{'posStr'} = join ";", @{$clstrInfoHsh_inThr_ref->{$clstrID}{'pos'}};
						$clstrInfoHsh_inThr_ref->{$clstrID}{'rdNumStr'} = join ";", @{$clstrInfoHsh_inThr_ref->{$clstrID}{'rdNum'}};
						$clstrInfoHsh_inThr_ref->{$clstrID}{'ALenStr'} = join ";", @{$clstrInfoHsh_inThr_ref->{$clstrID}{'ALen'}};
						$clstrInfoHsh_inThr_ref->{$clstrID}{'peakRdNum'} = $clstrInfoHsh_inThr_ref->{$clstrID}{'rdNum'}->[$maxdex];
						$clstrInfoHsh_inThr_ref->{$clstrID}{'peakPos'} = $clstrInfoHsh_inThr_ref->{$clstrID}{'pos'}->[$maxdex];
						$clstrInfoHsh_inThr_ref->{$clstrID}{'peakALen'} = $clstrInfoHsh_inThr_ref->{$clstrID}{'ALen'}->[$maxdex];
						$clstrInfoHsh_inThr_ref->{$clstrID}{'avgRdNum'} = sprintf "%.2f", sum(@{$clstrInfoHsh_inThr_ref->{$clstrID}{'rdNum'}})/$siteNum;
						$clstrInfoHsh_inThr_ref->{$clstrID}{'avgALen'} = sprintf "%.2f", sum(@{$clstrInfoHsh_inThr_ref->{$clstrID}{'ALen'}})/$siteNum;
						my $cntg = $clstrInfoHsh_inThr_ref->{$clstrID}{'cntg'};
						my $strnd = $clstrInfoHsh_inThr_ref->{$clstrID}{'strnd'};
						my $peakPos = $clstrInfoHsh_inThr_ref->{$clstrID}{'peakPos'};
						$clstrPeakByPosHsh_ref->{$cntg}{$peakPos}{$strnd} = $clstrID;
					}
				
					#---copy the in thr array
					%{$clstrInfoHsh_ref->{$clstrID}} = %{$clstrInfoHsh_inThr_ref->{$clstrID}};
					#---get the clstr stats
					$clstrStatHsh_ref->{'totalNum'} += $siteNum;
					if ($siteNum == 1) {
						$clstrStatHsh_ref->{'orphanNum'} += $siteNum;
					} else {
						$clstrStatHsh_ref->{'inClstrNum'} += $siteNum;
					}
				}
				delete $threadHsh{$threadNum};
				undef $clstrInfoHsh_inThr_ref;
			}
		}
		sleep 1;
	}
	
	#---calculate pct in cluster and orphan
	$clstrStatHsh_ref->{'inClstrPct'} = 100*$clstrStatHsh_ref->{'inClstrNum'}/$clstrStatHsh_ref->{'totalNum'};
	$clstrStatHsh_ref->{'orphanPct'} = 100*$clstrStatHsh_ref->{'orphanNum'}/$clstrStatHsh_ref->{'totalNum'};

	return ($clstrInfoHsh_ref, $clstrStatHsh_ref, $clstrPeakByPosHsh_ref);
}
sub countATGssTAAasMotif {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: polymerDiscriminativeRatio|4102, reportStatus|4806
#	appearInSub: analyzeEnd3PolyAMotifEnrichment|483
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir
#	output: 
#	toCall: &countATGssTAAasMotif($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir);
#	calledInLine: 496
#....................................................................................................................................................#
	my ($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultLogDir) = @_;
	
	my $polymerSize = 6;
	my $minFreq = 10;
	my $ratioLogPath = "$resultLogDir/sense.antisense.$polymerSize.mer.ratio.min.$minFreq.xls";
	
	my @adHocDSEAry = qw/TTTTTT ATTTTT TTATTT TTCTTT GTTTTT ATATTT TTATTT ATCTTT ATTTTT TTTTTT ATATTT GTCTTT/;
	my @adHocPASAry = qw/TTAATT TTAAGT TTAACT TTAAAT CTAATT CTAAGT CTAACT CTAAAT ATAATT ATAAGT ATAACT ATAAAT/;
	
	if (not -s $ratioLogPath) {
		my $pstvSeqHsh_ref = $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'tailASSeq'};
		my $ngtvSeqHsh_ref = $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'headSSSeq'};
		my ($ratioHsh_ref, $countPerKbHsh_ref, $freqHsh_ref) = &polymerDiscriminativeRatio($polymerSize, $pstvSeqHsh_ref, $ngtvSeqHsh_ref, $minFreq);#->4102
		open RATIOLOG, ">", $ratioLogPath;
		my @headerAry = qw/polymer PAS DSE rank TNum ANum CNum GNum log2Ratio linearRatio countPerKbPstv countPerKbNgtv freqPstv freqNgtv/;
		print RATIOLOG join "", (join "\t", (@headerAry), "\n");
		my $rank = 0;
		foreach my $polymer (sort {$ratioHsh_ref->{$b}{'linear'} <=> $ratioHsh_ref->{$a}{'linear'}} keys %{$ratioHsh_ref}) {
			$rank++;
			my $PAS = 'no';
			my $DSE = 'no';
			$PAS = 'yes' if (grep /$polymer/, @adHocPASAry);
			$DSE = 'yes' if (grep /$polymer/, @adHocDSEAry);
			my $TNum = ($polymer =~ tr/T//);
			my $ANum = ($polymer =~ tr/A//);
			my $CNum = ($polymer =~ tr/C//);
			my $GNum = ($polymer =~ tr/G//);
			my @outputAry = ($polymer, $PAS, $DSE, $rank, $TNum, $ANum, $CNum, $GNum, $ratioHsh_ref->{$polymer}{'log2'}, $ratioHsh_ref->{$polymer}{'linear'}, $countPerKbHsh_ref->{$polymer}{'pstv'}, $countPerKbHsh_ref->{$polymer}{'ngtv'}, $freqHsh_ref->{$polymer}{'pstv'}, $freqHsh_ref->{$polymer}{'ngtv'});
			print RATIOLOG join "", (join "\t", (@outputAry), "\n");
		}
		close RATIOLOG;
	} else {
		&reportStatus("ratioLogPath found. Skipping counting $polymerSize mers", 10, "\n");#->4806
	}
	
	return ();
}
sub countCtgryOnCntg {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: generateThreadHshWithRandomCntg|2558, reportStatus|4806
#	appearInSub: getNonStructuralCount|2953
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 6_filterAbovebackgroundPolyASites|263
#	input: $geneByCntgHsh_ref, $geneInfoHsh_ref, $margin3End, $margin5End, $maxThread, $nameTag, $pileupStorablePathHsh_ref, $resultStorableDir
#	output: $nonStructuralCount, $posBasedCtgryCountHsh_ref, $totalCount
#	toCall: my ($posBasedCtgryCountHsh_ref, $totalCount, $nonStructuralCount) = &countCtgryOnCntg($pileupStorablePathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir, $margin5End, $margin3End, $nameTag);
#	calledInLine: 2972
#....................................................................................................................................................#
	my ($pileupStorablePathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir, $margin5End, $margin3End, $nameTag) = @_;
	
	my $posBasedCtgryCountHshPlsPath = "$resultStorableDir/$nameTag.posBasedCtgryCountHsh.pls";
	my $posBasedCtgryCountHsh_ref = {};
	
	if (-s $posBasedCtgryCountHshPlsPath) {

		&reportStatus("Retrieving posBasedCtgryCountHsh", 0, "\n");#->4806
		$posBasedCtgryCountHsh_ref = retrieve($posBasedCtgryCountHshPlsPath);

	} else {
	
		#---define zero for all catgry
		my @cntgAry = (keys %{$pileupStorablePathHsh_ref});
		my $randCntgInThreadHsh_ref = &generateThreadHshWithRandomCntg($maxThread, \@cntgAry);#->2558
		my $cntgProc :shared = 0;
		my %threadHsh = ();

		foreach my $threadNum (sort {$a <=> $b} keys %{$randCntgInThreadHsh_ref}) {
			my $cntgAry_ref = \@{$randCntgInThreadHsh_ref->{$threadNum}};
			my $cntgNum = @{$randCntgInThreadHsh_ref->{$threadNum}};
			&reportStatus("$cntgNum cntgs spawned to thread $threadNum", 0, "\r");#->4806
			#---spawn a new thread
			($threadHsh{$threadNum}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781, the 
		
				sub {
					my ($cntgAry_ref) = @_;

					my $ctgryAbsCountInThrHsh_ref = {};
					$ctgryAbsCountInThrHsh_ref->{$geneInfoHsh_ref->{$_}{'ctgry'}} = 0 foreach (keys %{$geneInfoHsh_ref});
					$ctgryAbsCountInThrHsh_ref->{'unannotated'} = 0;
	
					foreach my $cntg (@{$cntgAry_ref}) {
						$cntgProc++;
						my $cntgCovAry_ref = retrieve($pileupStorablePathHsh_ref->{$cntg});
						my %cntgAnnoHsh = ();
		
						if (exists $geneByCntgHsh_ref->{$cntg}) {
							foreach my $geneID (keys %{$geneByCntgHsh_ref->{$cntg}}) {
						
								my ($startMargin, $endMargin);
								if ($geneInfoHsh_ref->{$geneID}{'strnd'} eq '+') {
									($startMargin, $endMargin) = ($margin5End, $margin3End);
								} else {
									($startMargin, $endMargin) = ($margin3End, $margin5End);
								}
							
								foreach my $i (${$geneInfoHsh_ref->{$geneID}{'geneRng'}}[0]-1-$startMargin..${$geneInfoHsh_ref->{$geneID}{'geneRng'}}[1]-1+$endMargin) {
									if (not $cntgAnnoHsh{$i}) {
										$cntgAnnoHsh{$i} = $geneInfoHsh_ref->{$geneID}{'ctgry'};
									} else {
										$cntgAnnoHsh{$i} = 'ambiguous';
									}
								}
							}
						}

						for my $i (0..$#{$cntgCovAry_ref}) {
							if ($cntgCovAry_ref->[$i]) {
								my $ctgry = 'unannotated';
								$ctgry = $cntgAnnoHsh{$i} if $cntgAnnoHsh{$i};
								$ctgryAbsCountInThrHsh_ref->{$ctgry} += sum((split /,/, $cntgCovAry_ref->[$i]));
							}
						}

						&reportStatus("$cntgProc cntg counted", 20, "\r");#->4806

					}

					#print $_."\n" foreach (keys %{$ctgryAbsCountInThrHsh_ref});
				
					return ($ctgryAbsCountInThrHsh_ref);
				}
				,($cntgAry_ref)
			);
		}

		#---wait and collect ctgryAbsCountInThrHsh_ref into posBasedCtgryCountHsh_ref
		$posBasedCtgryCountHsh_ref->{$geneInfoHsh_ref->{$_}{'ctgry'}} = 0 foreach (keys %{$geneInfoHsh_ref});
		$posBasedCtgryCountHsh_ref->{'unannotated'} = 0;

		while (keys %threadHsh) {
			foreach my $threadNum (keys %threadHsh) {
				my $thr = $threadHsh{$threadNum};
				if (not $thr->is_running()) {
					my ($ctgryAbsCountInThrHsh_ref) = $thr->join;
					$posBasedCtgryCountHsh_ref->{$_} += $ctgryAbsCountInThrHsh_ref->{$_} foreach (keys %{$ctgryAbsCountInThrHsh_ref});
					delete $threadHsh{$threadNum};
				}
			}
			sleep 1;
		}

		store($posBasedCtgryCountHsh_ref, $posBasedCtgryCountHshPlsPath);
	}

	my $totalCount = 0;
	$totalCount += $posBasedCtgryCountHsh_ref->{$_} foreach (keys %{$posBasedCtgryCountHsh_ref});
	my $nonStructuralCount = $totalCount;
	eval {
		$nonStructuralCount -= $posBasedCtgryCountHsh_ref->{'rRNA'} if $posBasedCtgryCountHsh_ref->{'rRNA'};
		$nonStructuralCount -= $posBasedCtgryCountHsh_ref->{'tRNA'} if $posBasedCtgryCountHsh_ref->{'tRNA'};
	};

	&reportStatus("totalCount = $totalCount", 20, "\n");#->4806
	&reportStatus("nonStructuralCount = $nonStructuralCount", 20, "\n");#->4806

	return ($posBasedCtgryCountHsh_ref, $totalCount, $nonStructuralCount);
}
sub countMotifOccurenceInCDSWithShortAndLongCisNAT {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: checkRunningThreadAndWaitToJoin|1227, defineCDSWithLongAndShortCisNAT|1890, generateDREMECmd|2445, getEnd3SequenceForCDSWithLongAndShortNAT|2771, polymerDiscriminativeRatio|4102, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	secondaryAppearInSection: >none
#	input: $fastaHsh_ref, $mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHshPlsPath, $resultDremeDir, $resultLogDir
#	output: 
#	toCall: &countMotifOccurenceInCDSWithShortAndLongCisNAT($mRNABasedPolyAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHshPlsPath, $mRNAInfoHsh_ref, $resultLogDir, $fastaHsh_ref, $resultDremeDir);
#	calledInLine: 356
#....................................................................................................................................................#
	my ($mRNABasedPolyAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHshPlsPath, $mRNAInfoHsh_ref, $resultLogDir, $fastaHsh_ref, $resultDremeDir) = @_;
	
	#---[16/10/2013 13:13] skip if no mRNATrnsfrgOvrlpInfoHshPlsPath input 
	exit if ($mRNATrnsfrgOvrlpInfoHshPlsPath eq 'none');
	
	my $end3RegionSize = 1000;
	my $mRNATrnsfrgOvrlpInfoHsh_ref = retrieve($mRNATrnsfrgOvrlpInfoHshPlsPath);
	
	my ($cisNATTypeHsh_ref) = &defineCDSWithLongAndShortCisNAT($mRNABasedPolyAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHsh_ref, $mRNAInfoHsh_ref, $resultLogDir, $end3RegionSize);#->1890
	my ($revcomCDSEnd3SeqHsh_ref) = &getEnd3SequenceForCDSWithLongAndShortNAT($cisNATTypeHsh_ref, $mRNAInfoHsh_ref, $fastaHsh_ref, $end3RegionSize);#->2771
	
	my $polymerSize = 6;
	my $minFreq = 10;
	my $maxk = 6;
	my $mink = 6;
	my $minE = 0.1;
	my $dremeMode = 'negative';
	
	my @adHocDSEAry = qw/TTTTTT ATTTTT TTATTT TTCTTT GTTTTT ATATTT TTATTT ATCTTT ATTTTT TTTTTT ATATTT GTCTTT/;
	my @adHocPASAry = qw/TTAATT TTAAGT TTAACT TTAAAT CTAATT CTAAGT CTAACT CTAAAT ATAATT ATAAGT ATAACT ATAAAT/;
	
	my %combinationHsh = ();
	
	$combinationHsh{1}{'+'} = [('end3ShortNAT', 'qry')];
	$combinationHsh{1}{'-'} = [('end3LongNAT', 'qry')];

	$combinationHsh{2}{'+'} = [('end3ShortNAT', 'qry')];
	$combinationHsh{2}{'-'} = [('end3ShortNAT', 'randCntrlEnd3OtherNAT')];

	$combinationHsh{3}{'+'} = [('end3LongNAT', 'qry')];
	$combinationHsh{3}{'-'} = [('end3LongNAT', 'randCntrlEnd3OtherNAT')];

	$combinationHsh{4}{'+'} = [('end3ShortNAT', 'randCntrlEnd3OtherNAT')];
	$combinationHsh{4}{'-'} = [('end3LongNAT', 'randCntrlEnd3OtherNAT')];

	$combinationHsh{5}{'+'} = [('end3ShortNAT', 'randCntrlNoNAT')];
	$combinationHsh{5}{'-'} = [('end3LongNAT', 'randCntrlNoNAT')];

	$combinationHsh{6}{'+'} = [('end3LongNAT', 'randCntrlEnd3OtherNAT')];
	$combinationHsh{6}{'-'} = [('end3LongNAT', 'randCntrlNoNAT')];

	$combinationHsh{7}{'+'} = [('end3LongNAT', 'qry')];
	$combinationHsh{7}{'-'} = [('end3LongNAT', 'randCntrlNoNAT')];

	$combinationHsh{8}{'+'} = [('end3ShortNAT', 'qry')];
	$combinationHsh{8}{'-'} = [('end3ShortNAT', 'randCntrlNoNAT')];
	
	foreach my $combNum (keys %combinationHsh) {

		my $tag = join ".", ($combinationHsh{$combNum}{'+'}->[0],$combinationHsh{$combNum}{'+'}->[1],$combinationHsh{$combNum}{'-'}->[0],$combinationHsh{$combNum}{'-'}->[1]);

		&reportStatus("motif analyses of $tag", 10, "\n");#->4806

		my $ratioLogPath = "$resultLogDir/$tag.$polymerSize.mer.ratio.min.$minFreq.xls";

		my $pstvSeqHsh_ref = $revcomCDSEnd3SeqHsh_ref->{$combinationHsh{$combNum}{'+'}->[0]}{$combinationHsh{$combNum}{'+'}->[1]};
		my $ngtvSeqHsh_ref = $revcomCDSEnd3SeqHsh_ref->{$combinationHsh{$combNum}{'-'}->[0]}{$combinationHsh{$combNum}{'-'}->[1]};

		if (not -s $ratioLogPath) {

			my ($ratioHsh_ref, $countPerKbHsh_ref, $freqHsh_ref) = &polymerDiscriminativeRatio($polymerSize, $pstvSeqHsh_ref, $ngtvSeqHsh_ref, $minFreq);#->4102
			open RATIOLOG, ">", $ratioLogPath;
			my @headerAry = qw/polymer PAS DSE rank TNum ANum CNum GNum log2Ratio linearRatio countPerKbPstv countPerKbNgtv freqPstv freqNgtv/;
			print RATIOLOG join "", (join "\t", (@headerAry), "\n");
			my $rank = 0;
			foreach my $polymer (sort {$ratioHsh_ref->{$b}{'linear'} <=> $ratioHsh_ref->{$a}{'linear'}} keys %{$ratioHsh_ref}) {
				$rank++;
				my $PAS = 'no';
				my $DSE = 'no';
				$PAS = 'yes' if (grep /$polymer/, @adHocPASAry);
				$DSE = 'yes' if (grep /$polymer/, @adHocDSEAry);
				my $TNum = ($polymer =~ tr/T//);
				my $ANum = ($polymer =~ tr/A//);
				my $CNum = ($polymer =~ tr/C//);
				my $GNum = ($polymer =~ tr/G//);
				my @outputAry = ($polymer, $PAS, $DSE, $rank, $TNum, $ANum, $CNum, $GNum, $ratioHsh_ref->{$polymer}{'log2'}, $ratioHsh_ref->{$polymer}{'linear'}, $countPerKbHsh_ref->{$polymer}{'pstv'}, $countPerKbHsh_ref->{$polymer}{'ngtv'}, $freqHsh_ref->{$polymer}{'pstv'}, $freqHsh_ref->{$polymer}{'ngtv'});
				print RATIOLOG join "", (join "\t", (@outputAry), "\n");
			}
			close RATIOLOG;
		} else {
			&reportStatus("ratioLogPath found. Skipping counting $polymerSize mers", 10, "\n");#->4806
		}
		
		#---[16/10/2013 20:47] DRREME
		my @mkDirAry;
		my $dremeParentDir = "$resultDremeDir/$tag/"; push @mkDirAry, $dremeParentDir;
		my $dremeFastaDir = "$dremeParentDir/fasta"; push @mkDirAry, $dremeFastaDir;
		my $dremeLogDir = "$dremeParentDir/log"; push @mkDirAry, $dremeLogDir;
		my $dremeOutDir = "$dremeParentDir/out"; push @mkDirAry, $dremeLogDir;
		my $dremeCmdDir = "$dremeParentDir/cmd"; push @mkDirAry, $dremeCmdDir;
		foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}
		
		my $positiveAlignHsh_ref = $pstvSeqHsh_ref;
		my $negativeAlignHsh_ref = $ngtvSeqHsh_ref;
		my $posSeqPath = "$dremeFastaDir/positive.fasta";
		my $negSeqPath = "$dremeFastaDir/negative.fasta";
		my $negLogPath = "$dremeLogDir/negative.log.txt";
		my $shuffleLogPath = "$dremeLogDir/shuffle.log.txt";

		my $dremeOutputHsh_ref = &generateDREMECmd($positiveAlignHsh_ref, $negativeAlignHsh_ref, $posSeqPath, $negSeqPath, $dremeOutDir, $shuffleLogPath, $negLogPath, $maxk, $mink, $minE, $dremeMode);#->2445
		
		foreach my $shuffleOrNegative (keys %{$dremeOutputHsh_ref}) {
			#my $dremeXMLPath = $dremeOutputHsh_ref->{$shuffleOrNegative}{'xml'};
			if (not -s $dremeOutputHsh_ref->{$shuffleOrNegative}{'xml'}) {
				&reportStatus("Issuing a Dreme thread to search $tag $shuffleOrNegative", 20, "\n");#->4806
				threads->create(sub{system "echo \"$dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'}\" >$dremeCmdDir/dreme.$shuffleOrNegative.cmd; $dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'} ";});
			} else {
				&reportStatus("Dreme XML found for $tag $shuffleOrNegative. Skipping", 20, "\n");#->4806
			}
		}
	}

	&checkRunningThreadAndWaitToJoin('yes', 1);#->1227

	return ();
}
sub createEmptyGenomeCovPerlStorable {
#....................................................................................................................................................#
#	subroutineCategory: storable
#	dependOnSub: reportStatus|4806
#	appearInSub: filterValidPolyASite|2140, getRawPolyASite|2977
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 5_getValidPolyASitesAndPlotRawDistribution|245, 6_filterAbovebackgroundPolyASites|263
#	input: $cntgCovPlsDir, $fastaHsh_ref
#	output: $cntgCovPlsPathHsh_ref
#	toCall: my ($cntgCovPlsPathHsh_ref) = &createEmptyGenomeCovPerlStorable($cntgCovPlsDir, $fastaHsh_ref);
#	calledInLine: 2166, 3006, 3009
#....................................................................................................................................................#

	my ($cntgCovPlsDir, $fastaHsh_ref) = @_;
	
	system("mkdir -pm 777 $cntgCovPlsDir");

	my $cntgCovPlsIdxHsh_ref = {};
	my $cntgCovPlsPathHsh_ref = {};

	foreach my $cntg (keys %{$fastaHsh_ref}) {
		
		&reportStatus("Creating empty storabe for $cntg", 20,"\r");#->4806
		
		my $cntgLen = length($fastaHsh_ref->{$cntg});
		my $cntgCovAry_ref = ();
		foreach (1..$cntgLen) {
			push @{$cntgCovAry_ref}, undef;
		}
		my $cntgCovPlsName = "$cntg.ary.pls";
		my $cntgCovPlsPath = "$cntgCovPlsDir/$cntgCovPlsName";
		$cntgCovPlsIdxHsh_ref->{$cntg} = $cntgCovPlsName;
		$cntgCovPlsPathHsh_ref->{$cntg} = $cntgCovPlsPath;
		store($cntgCovAry_ref, "$cntgCovPlsPath");
	}

	my $cntgCovIdxHshPath = "$cntgCovPlsDir/index.hsh.pls";
	store($cntgCovPlsIdxHsh_ref, "$cntgCovIdxHshPath");
	
	return ($cntgCovPlsPathHsh_ref);
}
sub createMotifFileFromBaseComposition {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: generateCleavageSiteWeblogoAndMotifFile|2400
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	input: $baseComHsh_ref, $bkgrndNtPercentHsh_ref, $motifFilePath
#	output: 
#	toCall: &createMotifFileFromBaseComposition($bkgrndNtPercentHsh_ref, $baseComHsh_ref, $motifFilePath);
#	calledInLine: 2438
#....................................................................................................................................................#
	my ($bkgrndNtPercentHsh_ref, $baseComHsh_ref, $motifFilePath) = @_;
	
	my $totalPos = keys %{$baseComHsh_ref};
	
	open INRMOTIF, ">", $motifFilePath;
	print INRMOTIF "MEME version 4\n";
	print INRMOTIF "\n";
	print INRMOTIF "ALPHABET= ACGT\n";
	print INRMOTIF "\n";
	print INRMOTIF "strands: +\n";
	print INRMOTIF "\n";
	print INRMOTIF "Background letter frequencies\n";
	print INRMOTIF "A $bkgrndNtPercentHsh_ref->{A} C $bkgrndNtPercentHsh_ref->{C} G $bkgrndNtPercentHsh_ref->{G} T $bkgrndNtPercentHsh_ref->{T}\n";
	print INRMOTIF "\n";
	print INRMOTIF "MOTIF Initiator\n";
	print INRMOTIF "letter-probability matrix: alength=4 w=$totalPos nsites=1000 E=0\n";
	foreach my $pos (sort {$a <=> $b} keys %{$baseComHsh_ref}) {
		print INRMOTIF join " ", ($baseComHsh_ref->{$pos}{'A'}, $baseComHsh_ref->{$pos}{'C'}, $baseComHsh_ref->{$pos}{'G'}, $baseComHsh_ref->{$pos}{'T'}."\n");
	}
	close INRMOTIF;
	return ();
}
sub createWeblogo {
#....................................................................................................................................................#
#	subroutineCategory: thridPartyApp
#	dependOnSub: >none
#	appearInSub: generateCleavageSiteWeblogoAndMotifFile|2400
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	input: $cmdPath, $fastaPath, $pdfPath, $seqAlignHsh_ref, $seqType, $title
#	output: none
#	toCall: &createWeblogo($seqAlignHsh_ref, $pdfPath, $fastaPath, $cmdPath, $seqType, $title);
#	calledInLine: 2430
#....................................................................................................................................................#

	my ($seqAlignHsh_ref, $pdfPath, $fastaPath, $cmdPath, $seqType, $title) = @_;
	
	#---print the fasta
	open (FASTA, ">", $fastaPath);
	foreach my $seqName (keys %{$seqAlignHsh_ref}) {
		print FASTA ">$seqName\n";
		print FASTA "$seqAlignHsh_ref->{$seqName}\n";
	}
	close FASTA;
	my $cmd = "weblogo --fin $fastaPath --datatype fasta --format pdf --fout $pdfPath --size large --sequence-type $seqType --title \"$title\" --color-scheme classic";
	system ("echo \"$cmd\" >$cmdPath");
	system ($cmd);
	
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general, reporting
#	dependOnSub: >none
#	appearInSub: checkOverlapAndProximity|987, getCtgryGeneInfo|2734, printBothFHAndStdout|4176, printCMDLogOrFinishMessage|4199, readGFF_oneRNAPerGene|4534, reportStatus|4806, zipUnzipCntgCovInPlsPathHsh|4866
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 0_startingTasks|93, 13_finishingTasks|362, 4_processGenomeInformation|209, 5_getValidPolyASitesAndPlotRawDistribution|245, 9_assignPolyAClustersToGenes|300
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 1123, 2753, 2766, 4193, 4194, 4219, 4222, 4227, 4554, 4823, 4881
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub defineCDSWithLongAndShortCisNAT {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: reportStatus|4806
#	appearInSub: countMotifOccurenceInCDSWithShortAndLongCisNAT|1642
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $end3RegionSize, $mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHsh_ref, $resultLogDir
#	output: $cisNATTypeHsh_ref
#	toCall: my ($cisNATTypeHsh_ref) = &defineCDSWithLongAndShortCisNAT($mRNABasedPolyAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHsh_ref, $mRNAInfoHsh_ref, $resultLogDir, $end3RegionSize);
#	calledInLine: 1661
#....................................................................................................................................................#
	my ($mRNABasedPolyAInfoHsh_ref, $mRNATrnsfrgOvrlpInfoHsh_ref, $mRNAInfoHsh_ref, $resultLogDir, $end3RegionSize) = @_;
	
	my $minTotalOvrlpSize = $end3RegionSize;
	my $maxTotalOvrlpSize = 400;
	my $minAvgOvrlpSize = $minTotalOvrlpSize/2;
	my $maxAvgOvrlpSize = $maxTotalOvrlpSize/2;
	my $minCDSLength = $minTotalOvrlpSize;
	
	&reportStatus("Defining cisNAT types", 10, "\n");#->4806
	
	#---[16/10/2013 14:20] create empty array for all NAT types
	my $cisNATTypeHsh_ref = {};
	$cisNATTypeHsh_ref->{$_} = {} foreach (qw/CDSTooShort noNAT NATFromNeighbor nonEnd3NAT end3OtherNAT end3LongNAT end3ShortNAT/);
	
	foreach my $mRNAID (sort keys %{$mRNAInfoHsh_ref}) {
		my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
		my $CDSLength = $CDSRngAry[-1] - $CDSRngAry[0] + 1;
		my $regHitStr = $mRNATrnsfrgOvrlpInfoHsh_ref->{$mRNAID}{'a'}{'regHitStr'};
		
		#---[16/10/2013 13:18] get only genes long than minCDSLength
		my $NAType;
		if ($CDSLength >= $minCDSLength) {
			if ($mRNATrnsfrgOvrlpInfoHsh_ref->{$mRNAID}{'a'}{'trnsfrgNum'} > 0) {
				#---[16/10/2013 13:23] get only genes with AS transfrag NOT overlap with neighbor
				if ($mRNATrnsfrgOvrlpInfoHsh_ref->{$mRNAID}{'a'}{'neighborOvrlp'} == 0) {
					#---[16/10/2013 13:23] get only genes with AS transfrag from 3'end
					if ($regHitStr =~ m/\+$/) {
						my $total_ovrlpSize = $mRNATrnsfrgOvrlpInfoHsh_ref->{$mRNAID}{'a'}{'total_ovrlpSize'};
						my $avg_ovrlpSize = $mRNATrnsfrgOvrlpInfoHsh_ref->{$mRNAID}{'a'}{'avg_ovrlpSize'};
						my $closeRltvPos = $mRNABasedPolyAInfoHsh_ref->{'a'}{'body'}{$mRNAID}{'closeRltvPos'};

						#---[16/10/2013 14:06] long overlap and no polyA close to TAA
						if ($total_ovrlpSize >= $minTotalOvrlpSize and $avg_ovrlpSize >= $minAvgOvrlpSize and ($closeRltvPos == 999999 or $closeRltvPos <= -$minTotalOvrlpSize)) {
							$NAType = 'end3LongNAT';
						} elsif ($total_ovrlpSize <= $maxTotalOvrlpSize and $avg_ovrlpSize >= $maxAvgOvrlpSize and $closeRltvPos >= -$maxTotalOvrlpSize and $closeRltvPos != 999999) {
							$NAType = 'end3ShortNAT';
						} else {
							$NAType = 'end3OtherNAT';
						}
						
					} else {
						$NAType = 'nonEnd3NAT';
					}
				} else {
					$NAType = 'NATFromNeighbor';
				}
			} else {
				$NAType = 'noNAT';
			}
		} else {
			$NAType = 'CDSTooShort';
		}

		$cisNATTypeHsh_ref->{$NAType}{$mRNAID} = $regHitStr;
	}
	
	open NATTYPELOG, ">", "$resultLogDir/cisNATType.xls";
	print NATTYPELOG join "", (join "\t", (qw/mRNAID description locationTag strnd CDSLength NAType regHitStr/)), "\n";
	foreach my $NAType (sort keys %{$cisNATTypeHsh_ref}) {
		my $geneNum = keys %{$cisNATTypeHsh_ref->{$NAType}};
		&reportStatus("$NAType = $geneNum", 10, "\n");#->4806
		foreach my $mRNAID (keys %{$cisNATTypeHsh_ref->{$NAType}}) {
			my $description = $mRNAInfoHsh_ref->{$mRNAID}{'description'};
			my $cntg = $mRNAInfoHsh_ref->{$mRNAID}{'cntg'};
			my $strnd = $mRNAInfoHsh_ref->{$mRNAID}{'strnd'};
			my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
			my $locationTag = $cntg.":".$CDSRngAry[-1]."-".$CDSRngAry[0];
			my $CDSLength = $CDSRngAry[-1] - $CDSRngAry[0] + 1;
			my $regHitStr = $cisNATTypeHsh_ref->{$NAType}{$mRNAID};
			my @outputAry = ($mRNAID, $description, $locationTag, $strnd, $CDSLength, $NAType, $regHitStr);
			print NATTYPELOG join "", (join "\t", (@outputAry)), "\n";
		}
	}
	close NATTYPELOG;
	
	return ($cisNATTypeHsh_ref);
}
sub dremeATGssTAAasMotif {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkRunningThreadAndWaitToJoin|1227, generateDREMECmd|2445, reportStatus|4806
#	appearInSub: analyzeEnd3PolyAMotifEnrichment|483
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultDremeDir
#	output: 
#	toCall: &dremeATGssTAAasMotif($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultDremeDir);
#	calledInLine: 497
#....................................................................................................................................................#
	my ($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $resultDremeDir) = @_;
	
	my $mink = 6;
	my $maxk = 6;
	my $minE = 0.001;
	my $dremeMode = 'negative'; #---shuffle or negative or both;
	
	my %tmpCmbntn = ();

	$tmpCmbntn{'headSS'}{'pos'} = 'headSSSeq';
	$tmpCmbntn{'headSS'}{'neg'} = 'tailASSeq';

	$tmpCmbntn{'tailAS'}{'pos'} = 'tailASSeq';
	$tmpCmbntn{'tailAS'}{'neg'} = 'headSSSeq';

	foreach my $headSSOrTailAS (keys %tmpCmbntn) {

		my @mkDirAry;
		my $dremeParentDir = "$resultDremeDir/$headSSOrTailAS.mink$mink.maxk$maxk.minE$minE/"; push @mkDirAry, $dremeParentDir;
		my $dremeFastaDir = "$dremeParentDir/fasta"; push @mkDirAry, $dremeFastaDir;
		my $dremeLogDir = "$dremeParentDir/log"; push @mkDirAry, $dremeLogDir;
		my $dremeOutDir = "$dremeParentDir/out"; push @mkDirAry, $dremeLogDir;
		my $dremeCmdDir = "$dremeParentDir/cmd"; push @mkDirAry, $dremeCmdDir;
		foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}
		
		my $positiveAlignHsh_ref = $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{$tmpCmbntn{$headSSOrTailAS}{'pos'}};
		my $negativeAlignHsh_ref = $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{$tmpCmbntn{$headSSOrTailAS}{'neg'}};
		my $posSeqPath = "$dremeFastaDir/positive.fasta";
		my $negSeqPath = "$dremeFastaDir/negative.fasta";
		my $shuffleLogPath = "$dremeLogDir/shuffle.log.txt";
		my $negLogPath = "$dremeLogDir/negative.log.txt";

		my $dremeOutputHsh_ref = &generateDREMECmd($positiveAlignHsh_ref, $negativeAlignHsh_ref, $posSeqPath, $negSeqPath, $dremeOutDir, $shuffleLogPath, $negLogPath, $maxk, $mink, $minE, $dremeMode);#->2445
		
		foreach my $shuffleOrNegative (keys %{$dremeOutputHsh_ref}) {
			#my $dremeXMLPath = $dremeOutputHsh_ref->{$shuffleOrNegative}{'xml'};
			if (not -s $dremeOutputHsh_ref->{$shuffleOrNegative}{'xml'}) {
				&reportStatus("Issuing a Dreme thread to search $headSSOrTailAS $shuffleOrNegative", 20, "\n");#->4806
				threads->create(sub{system "echo \"$dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'}\" >$dremeCmdDir/dreme.$shuffleOrNegative.cmd; $dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'} ";});
			} else {
				&reportStatus("Dreme XML found for $headSSOrTailAS $shuffleOrNegative. Skipping", 20, "\n");#->4806
			}
		}
	}
	
	&checkRunningThreadAndWaitToJoin('yes', 1);#->1227
	
	return ();
}
sub dremePolyASiteMotif {
#....................................................................................................................................................#
#	subroutineCategory: motif
#	dependOnSub: generateDREMECmd|2445, reportStatus|4806
#	appearInSub: categorizePolyAClstrForDreme|888
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	input: $clstrIDFiltrHsh_ref, $clstrInfoHsh_ref, $clstrSeqRng, $dremeParamHsh_ref, $regionInfoHsh_ref, $resultDremeDir
#	output: $polyADremePathHsh_ref
#	toCall: my ($polyADremePathHsh_ref) = &dremePolyASiteMotif($clstrInfoHsh_ref, $clstrIDFiltrHsh_ref, $clstrSeqRng, $regionInfoHsh_ref, $resultDremeDir, $dremeParamHsh_ref);
#	calledInLine: 954
#....................................................................................................................................................#
	my ($clstrInfoHsh_ref, $clstrIDFiltrHsh_ref, $clstrSeqRng, $regionInfoHsh_ref, $resultDremeDir, $dremeParamHsh_ref) = @_;
	
	my $polyADremePathHsh_ref = {};
	
	foreach my $regionType (keys %{$regionInfoHsh_ref}) {
		
		#---[07/10/2013 19:37] get the dreme parameters
		my $maxk = $dremeParamHsh_ref->{$regionType}{'maxk'};
		my $mink = $dremeParamHsh_ref->{$regionType}{'mink'};
		my $minE = $dremeParamHsh_ref->{$regionType}{'minE'};
		my $dremeMode = $dremeParamHsh_ref->{$regionType}{'dremeMode'};

		#---[07/10/2013 17:34] resolve the region to be take as positive and negetive alignment
		my %regionToTakeHsh = ();
		foreach my $posOrNeg (keys %{$regionInfoHsh_ref->{$regionType}}) {
			my ($start, $end) = @{$regionInfoHsh_ref->{$regionType}{$posOrNeg}};
			if (($start < 0 and $end < 0) and (abs($end) < abs($start))) {

				$regionToTakeHsh{$posOrNeg}{'seq'} = 'upStrmSeq';
				$regionToTakeHsh{$posOrNeg}{'length'} = abs($start) - abs($end);
				$regionToTakeHsh{$posOrNeg}{'startIndex'} = $clstrSeqRng - abs($start);
			
			} elsif (($start >= 0 and $end > 0) and (abs($end) > abs($start))) {

				$regionToTakeHsh{$posOrNeg}{'seq'} = 'dnStrmSeq';
				$regionToTakeHsh{$posOrNeg}{'length'} = abs($end) - abs($start);
				$regionToTakeHsh{$posOrNeg}{'startIndex'} = $start;
		
			} else {
				die "region unspecified, qutting\n";
			}
		}

		#---[07/10/2013 17:41] different set of clstrID based on clstrType
		foreach my $clstrType (keys %{$clstrIDFiltrHsh_ref}) {
			my $alignHsh_ref = {};
			foreach my $clstrID (keys %{$clstrInfoHsh_ref}) {

				#---[07/10/2013 17:40] filter the clstrID
				next if not $clstrIDFiltrHsh_ref->{$clstrType}{$clstrID};

				#---[07/10/2013 17:40] get the sequences
				foreach my $posOrNeg (keys %regionToTakeHsh) {
					my $alignSeq = substr $clstrInfoHsh_ref->{$clstrID}{$regionToTakeHsh{$posOrNeg}{'seq'}}, $regionToTakeHsh{$posOrNeg}{'startIndex'}, $regionToTakeHsh{$posOrNeg}{'length'};
					#&reportStatus("$clstrID $posOrNeg $clstrType $regionType $regionToTakeHsh{$posOrNeg}{'startIndex'} $regionToTakeHsh{$posOrNeg}{'length'}", 10, "\n") if not $alignSeq;#->4806
					$alignHsh_ref->{$posOrNeg}{$clstrID} = $alignSeq;
				}
			}

			my @mkDirAry;
			my $dremeParentDir = "$resultDremeDir/$regionType/$clstrType/"; push @mkDirAry, $dremeParentDir;
			my $dremeFastaDir = "$dremeParentDir/fasta"; push @mkDirAry, $dremeFastaDir;
			my $dremeLogDir = "$dremeParentDir/log"; push @mkDirAry, $dremeLogDir;
			my $dremeOutDir = "$dremeParentDir/out"; push @mkDirAry, $dremeLogDir;
			my $dremeCmdDir = "$dremeParentDir/cmd"; push @mkDirAry, $dremeCmdDir;
			foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}
		
			my $positiveAlignHsh_ref = $alignHsh_ref->{'pos'};
			my $negativeAlignHsh_ref = $alignHsh_ref->{'neg'};
			my $posSeqPath = "$dremeFastaDir/positive.fasta";
			my $negSeqPath = "$dremeFastaDir/negative.fasta";
			my $shuffleLogPath = "$dremeLogDir/shuffle.log.txt";
			my $negLogPath = "$dremeLogDir/negative.log.txt";

			$polyADremePathHsh_ref->{$regionType}{$clstrType}{'seq'}{'pos'} = $posSeqPath;
			$polyADremePathHsh_ref->{$regionType}{$clstrType}{'seq'}{'neg'} = $negSeqPath;

			my $dremeOutputHsh_ref = &generateDREMECmd($positiveAlignHsh_ref, $negativeAlignHsh_ref, $posSeqPath, $negSeqPath, $dremeOutDir, $shuffleLogPath, $negLogPath, $maxk, $mink, $minE, $dremeMode);#->2445
		
			foreach my $shuffleOrNegative (keys %{$dremeOutputHsh_ref}) {
				my $dremeXMLPath = $dremeOutputHsh_ref->{$shuffleOrNegative}{'xml'};

				$polyADremePathHsh_ref->{$regionType}{$clstrType}{'xml'}{$shuffleOrNegative} = $dremeXMLPath;
				$polyADremePathHsh_ref->{$regionType}{$clstrType}{'txt'}{$shuffleOrNegative} = $dremeOutputHsh_ref->{$shuffleOrNegative}{'txt'};
				$polyADremePathHsh_ref->{$regionType}{$clstrType}{'html'}{$shuffleOrNegative} = $dremeOutputHsh_ref->{$shuffleOrNegative}{'html'};

				if (not -s $dremeXMLPath) {
					&reportStatus("Issuing a Dreme thread to search $clstrType $shuffleOrNegative", 20, "\n");#->4806
					system "echo \"$dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'}\" >$dremeCmdDir/dreme.$shuffleOrNegative.cmd; $dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'}";
				} else {
					&reportStatus("Dreme XML found for $clstrType $shuffleOrNegative. Skipping", 20, "\n");#->4806
				}
			}
		}
	}
	
	return ($polyADremePathHsh_ref);
}
sub filterValidPolyASite {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: createEmptyGenomeCovPerlStorable|1770, printWigFromCovPerlStorable|4474, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 6_filterAbovebackgroundPolyASites|263
#	secondaryAppearInSection: >none
#	input: $IGVGenomePath, $abvBkgdValCutoffHsh_ref, $controlPileupPlsPathHsh_ref, $fastaHsh_ref, $indivPolyASiteCutoffHsh_ref, $polyATailLenPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $resultStorableDir, $resultWigDir
#	output: $validPolyASitePlsPathHsh_ref
#	toCall: my ($validPolyASitePlsPathHsh_ref) = &filterValidPolyASite($rawPolyASitePlsPathHsh_ref, $controlPileupPlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $abvBkgdValCutoffHsh_ref, $indivPolyASiteCutoffHsh_ref, $resultStorableDir, $fastaHsh_ref, $IGVGenomePath, $resultWigDir);
#	calledInLine: 269
#....................................................................................................................................................#
	my ($rawPolyASitePlsPathHsh_ref, $controlPileupPlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $abvBkgdValCutoffHsh_ref, $indivPolyASiteCutoffHsh_ref, $resultStorableDir, $fastaHsh_ref, $IGVGenomePath, $resultWigDir) = @_;
	
	my $validPolyASitePlsPathHshPlsPath = "$resultStorableDir/validPolyASitePlsPathHsh.pls";
	my $validPolyASitePlsPathHsh_ref = {};

	&reportStatus("Getting valid polyA sites", 10, "\n");#->4806
	
	if (-s $validPolyASitePlsPathHshPlsPath) {
	
		&reportStatus("Retrieving validPolyASitePlsPathHsh", 10, "\n");#->4806
		$validPolyASitePlsPathHsh_ref = retrieve($validPolyASitePlsPathHshPlsPath);

	} else {
	
		my $cntgCovPlsDir = "$resultStorableDir/validPolyASiteCntg/";
		($validPolyASitePlsPathHsh_ref) = &createEmptyGenomeCovPerlStorable($cntgCovPlsDir, $fastaHsh_ref);#->1770
		my $cntgProc = 0;
		
		foreach my $cntg (keys %{$validPolyASitePlsPathHsh_ref}) {
			$cntgProc++;
			&reportStatus("$cntgProc cntg processed", 20, "\r");#->4806

			my %tmpCntgCovAryHsh = ();
			$tmpCntgCovAryHsh{'rawPolyA'} = retrieve($rawPolyASitePlsPathHsh_ref->{$cntg});
			$tmpCntgCovAryHsh{'control'} = retrieve($controlPileupPlsPathHsh_ref->{$cntg});
			$tmpCntgCovAryHsh{'ALen'} = retrieve($polyATailLenPlsPathHsh_ref->{$cntg});
			my $cntgValidPolyAAry_ref = retrieve($validPolyASitePlsPathHsh_ref->{$cntg});
	
			foreach my $i (0..$#{$tmpCntgCovAryHsh{'rawPolyA'}}) {
				if ($tmpCntgCovAryHsh{'rawPolyA'}->[$i]) {
					my %tmpValidPolyAHsh = ('+'=>0, '-'=>0);
					my %tmpCovHsh = ();
					foreach (keys %tmpCntgCovAryHsh) {
						if ($tmpCntgCovAryHsh{$_}->[$i]) {
							($tmpCovHsh{'+'}{$_}, $tmpCovHsh{'-'}{$_}) = split /,/, $tmpCntgCovAryHsh{$_}->[$i];
						} else {
							($tmpCovHsh{'+'}{$_}, $tmpCovHsh{'-'}{$_}) = (0,0);
						}
					}
					foreach my $strnd (keys %tmpCovHsh) {
						#---check minRdNum 
						next if ($tmpCovHsh{$strnd}{'rawPolyA'} < $indivPolyASiteCutoffHsh_ref->{'minRdNum'});
						#---check minAvgRdATailLen
						next if ($tmpCovHsh{$strnd}{'ALen'} < $indivPolyASiteCutoffHsh_ref->{'minAvgRdATailLen'});
					
						#---check polyAToCntrlCountRatio 
						if ($tmpCovHsh{$strnd}{'control'} > 0) {
							my $ratio = $tmpCovHsh{$strnd}{'rawPolyA'}/$tmpCovHsh{$strnd}{'control'};
							next if ($ratio < $abvBkgdValCutoffHsh_ref->{'linear'}{'polyAToCntrlCountRatio'});
						} else {
							#---check polyACountWithZeroCntrl 
							next if ($tmpCovHsh{$strnd}{'rawPolyA'} < $abvBkgdValCutoffHsh_ref->{'linear'}{'polyACountWithZeroCntrl'});
						}
						$tmpValidPolyAHsh{$strnd} = $tmpCovHsh{$strnd}{'rawPolyA'};
					}
				
					if ($tmpValidPolyAHsh{'+'} > 0 or $tmpValidPolyAHsh{'-'} > 0) {
						$cntgValidPolyAAry_ref->[$i] = join ",", ($tmpValidPolyAHsh{'+'}, $tmpValidPolyAHsh{'-'});
					}
				}
			}
		
			store($cntgValidPolyAAry_ref, $validPolyASitePlsPathHsh_ref->{$cntg});
		}

		&printWigFromCovPerlStorable($validPolyASitePlsPathHsh_ref, "$resultWigDir/valid.polyA.num", $IGVGenomePath);#->4474
	}
	
	store($validPolyASitePlsPathHsh_ref, $validPolyASitePlsPathHshPlsPath);
	
	return ($validPolyASitePlsPathHsh_ref);
}
sub gatherPolyAInfo {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 10_gatherAndReportPolyAInfo|320
#	secondaryAppearInSection: >none
#	input: $clstrInfoHsh_ref, $mRNAGeneBodyPolyAInfoHsh_ref, $mRNAHeadAntiSensePolyAInfoHsh_ref, $mRNAInfoHsh_ref, $mRNATailSensePolyAInfoHsh_ref, $resultStorableDir
#	output: $clstrBasedPolyAInfoHsh_ref, $mRNABasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref
#	toCall: my ($mRNABasedPolyAInfoHsh_ref, $clstrBasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref) = &gatherPolyAInfo($mRNATailSensePolyAInfoHsh_ref, $mRNAGeneBodyPolyAInfoHsh_ref, $mRNAHeadAntiSensePolyAInfoHsh_ref, $clstrInfoHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir);
#	calledInLine: 325
#....................................................................................................................................................#
	my ($mRNATailSensePolyAInfoHsh_ref, $mRNAGeneBodyPolyAInfoHsh_ref, $mRNAHeadAntiSensePolyAInfoHsh_ref, $clstrInfoHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir) = @_;
	
	#---[05/10/2013 17:19] go throung all clusters
	my %tmpPolyATypeHshRefHsh = ();
	
	$tmpPolyATypeHshRefHsh{'s'}{'tail'} = $mRNATailSensePolyAInfoHsh_ref;
	$tmpPolyATypeHshRefHsh{'s'}{'body'} = $mRNAGeneBodyPolyAInfoHsh_ref->{'s'};
	$tmpPolyATypeHshRefHsh{'a'}{'body'} = $mRNAGeneBodyPolyAInfoHsh_ref->{'a'};
	$tmpPolyATypeHshRefHsh{'a'}{'head'} = $mRNAHeadAntiSensePolyAInfoHsh_ref;

	my $polyATypeTagHsh_ref = {};

	#---[05/10/2013 19:57] get clstr based information
	&reportStatus("Gathering cluster based polyA info", 10, "\n");#->4806
	my $clstrBasedPolyAInfoHsh_ref = {};
	foreach my $dirtn (keys %tmpPolyATypeHshRefHsh) {
		foreach my $tailOrBodyOrHead (keys %{$tmpPolyATypeHshRefHsh{$dirtn}}) {
			my $polyATypeTag = $dirtn."_".$tailOrBodyOrHead;
			
			#---[06/10/2013 14:20] stored the polyA type for latter use
			$polyATypeTagHsh_ref->{$dirtn}{$tailOrBodyOrHead} = $polyATypeTag;

			my $hsh_ref = $tmpPolyATypeHshRefHsh{$dirtn}{$tailOrBodyOrHead};
			foreach my $mRNAID (keys %{$hsh_ref}) {
				@{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}} = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
				my $CDSLength = $mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}->[-1]-$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}->[0];
				
				foreach my $clstrID (keys %{$hsh_ref->{$mRNAID}}) {
					my $distFromCDSEnd = $hsh_ref->{$mRNAID}{$clstrID}{'distFromCDSEnd'};
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'mRNAID'} = $mRNAID;
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'CDSLength'} = $CDSLength;
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'distFromCDSEnd'} = $distFromCDSEnd;
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'longALen'} = 'no';
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'peak'} = 'no';
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'close'} = 'no';
					$clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'far'} = 'no';
				}
			}
		}
	}

	#---[05/10/2013 19:57] get gene based information
	&reportStatus("Gathering gene based polyA info", 10, "\n");#->4806
	my $mRNABasedPolyAInfoHsh_ref = {};
	foreach my $dirtn (keys %tmpPolyATypeHshRefHsh) {
		foreach my $tailOrBodyOrHead (keys %{$tmpPolyATypeHshRefHsh{$dirtn}}) {
			my $polyATypeTag = $dirtn."_".$tailOrBodyOrHead;
			my $hsh_ref = $tmpPolyATypeHshRefHsh{$dirtn}{$tailOrBodyOrHead};
			foreach my $mRNAID (keys %{$mRNAInfoHsh_ref}) {
				my $clstrIDStr = 'none';
				my $rltvPosStr = 'none';
				my $rdNumStr = 'none';
				my $ALenStr = 'none';

				my $clstrNum = 0;
				my $avgALen = 0;
				my $avgRdNum = 0;
				my $peakRdNum = 0;
				my $peakALen = 0;

				my $closeRltvPos = 999999;
				my $farRltvPos = 0;
				my $peakRltvPos = 999999;
				my $longALenRltvPos = 999999;

				my $closeClstrID = 'none';
				my $farClstrID = 'none';
				my $peakClstrID = 'none';
				my $longALenClstrID = 'none';
				
				my $peakPos = 'none';

				my $fromNeigbhor = 'none';

				if ($hsh_ref->{$mRNAID}) {
					$fromNeigbhor = 'no';
					my %tmpDataHsh = ();
					
					#---[06/10/2013 19:19] clstrID sort by distFromCDSEnd
					foreach my $clstrID (sort {$hsh_ref->{$mRNAID}{$a}{'distFromCDSEnd'} <=> $hsh_ref->{$mRNAID}{$b}{'distFromCDSEnd'}} keys %{$hsh_ref->{$mRNAID}}) {
						
						if ($clstrBasedPolyAInfoHsh_ref->{$clstrID}{'s_tail'}) {
							if ($clstrBasedPolyAInfoHsh_ref->{$clstrID}{'s_tail'}{'mRNAID'} ne $mRNAID) {#----mRNAID belong to another gene
								$fromNeigbhor = 'yes';
							}
						}
						
						my $distFromCDSEnd = $hsh_ref->{$mRNAID}{$clstrID}{'distFromCDSEnd'};
						my $rdNum = $clstrInfoHsh_ref->{$clstrID}{'peakRdNum'};
						my $ALen = $clstrInfoHsh_ref->{$clstrID}{'peakALen'};
						my $pos = $clstrInfoHsh_ref->{$clstrID}{'peakPos'};
						
						push @{$tmpDataHsh{'rltvPos'}}, $distFromCDSEnd;
						push @{$tmpDataHsh{'clstrID'}}, $clstrID;
						push @{$tmpDataHsh{'ALen'}}, $ALen;
						push @{$tmpDataHsh{'rdNum'}}, $rdNum;
						
						$clstrNum++;
						if (abs $distFromCDSEnd < abs $closeRltvPos) {
							$closeRltvPos = $distFromCDSEnd;
							$closeClstrID = $clstrID;
						}
						
						if (abs $distFromCDSEnd > abs $farRltvPos) {
							$farRltvPos = $distFromCDSEnd;
							$farClstrID = $clstrID;
						}

						if ($rdNum > $peakRdNum) {
							$peakRltvPos = $distFromCDSEnd;
							$peakRdNum = $rdNum;
							$peakClstrID = $clstrID;
							$peakPos = $pos;
						}
						
						if ($ALen > $peakALen) {
							$longALenRltvPos = $distFromCDSEnd;
							$peakALen = $ALen;
							$longALenClstrID = $clstrID;
						}
					}
					
					if ($tmpDataHsh{'clstrID'}) {
						$clstrBasedPolyAInfoHsh_ref->{$closeClstrID}{$polyATypeTag}{'close'} = 'yes';
						$clstrBasedPolyAInfoHsh_ref->{$farClstrID}{$polyATypeTag}{'far'} = 'yes';
						$clstrBasedPolyAInfoHsh_ref->{$longALenClstrID}{$polyATypeTag}{'longALen'} = 'yes';
						$clstrBasedPolyAInfoHsh_ref->{$peakClstrID}{$polyATypeTag}{'peak'} = 'yes';

						$clstrIDStr = join ";", @{$tmpDataHsh{'clstrID'}};
						$rltvPosStr = join ";", @{$tmpDataHsh{'rltvPos'}};
						$ALenStr = join ";", @{$tmpDataHsh{'ALen'}};
						$rdNumStr = join ";", @{$tmpDataHsh{'rdNum'}};
						$avgALen = sprintf "%.2f", sum(@{$tmpDataHsh{'ALen'}})/@{$tmpDataHsh{'ALen'}};
						$avgRdNum = sprintf "%.2f", sum(@{$tmpDataHsh{'rdNum'}})/@{$tmpDataHsh{'rdNum'}};
					}
				}
				
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'clstrIDStr'} = $clstrIDStr;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'rltvPosStr'} = $rltvPosStr;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'rdNumStr'} = $rdNumStr;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'ALenStr'} = $ALenStr;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'clstrNum'} = $clstrNum;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'avgALen'} = $avgALen;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'avgRdNum'} = $avgRdNum;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'closeRltvPos'} = $closeRltvPos;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'farRltvPos'} = $farRltvPos;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakRltvPos'} = $peakRltvPos;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'longALenRltvPos'} = $longALenRltvPos;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'closeClstrID'} = $closeClstrID;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'farClstrID'} = $farClstrID;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakClstrID'} = $peakClstrID;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'longALenClstrID'} = $longALenClstrID;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakRdNum'} = $peakRdNum;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakALen'} = $peakALen;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakPos'} = $peakPos;
				$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'fromNeigbhor'} = $fromNeigbhor;
			}
		}
	}
	
	store ($mRNABasedPolyAInfoHsh_ref, "$resultStorableDir/mRNABasedPolyAInfoHsh.pls");

	return ($mRNABasedPolyAInfoHsh_ref, $clstrBasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref);
}
sub generateCleavageSiteWeblogoAndMotifFile {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: calculateBaseCompositionInAlignments|762, createMotifFileFromBaseComposition|1811, createWeblogo|1845, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	secondaryAppearInSection: >none
#	input: $cleavageSiteSeqHsh_ref, $clstrSeqBaseProportionHsh_ref, $clstrSeqHsh_ref, $resultMotifDir, $weblogoDirHsh_ref
#	output: 
#	toCall: &generateCleavageSiteWeblogoAndMotifFile($cleavageSiteSeqHsh_ref, $clstrSeqHsh_ref, $weblogoDirHsh_ref, $resultMotifDir, $clstrSeqBaseProportionHsh_ref);
#	calledInLine: 341
#....................................................................................................................................................#
	my ($cleavageSiteSeqHsh_ref, $clstrSeqHsh_ref, $weblogoDirHsh_ref, $resultMotifDir, $clstrSeqBaseProportionHsh_ref) = @_;
	
	foreach my $polyATypeTag (keys %{$cleavageSiteSeqHsh_ref}) {
		&reportStatus("Generating weblogo for $polyATypeTag cleavageSite", 10, "\n");#->4806
		my $numGene = 0;
		my $seqAlignHsh_ref = {};

		foreach my $clstrID (keys %{$cleavageSiteSeqHsh_ref->{$polyATypeTag}}) {
			$numGene++;
			$seqAlignHsh_ref->{$clstrID} = $cleavageSiteSeqHsh_ref->{$polyATypeTag}{$clstrID};
		}

		{#---plot weblogo
			my $nameTag = $polyATypeTag.".cleavageSite";
			my $pdfPath = "$weblogoDirHsh_ref->{pdf}/$nameTag.pdf";
			my $fastaPath = "$weblogoDirHsh_ref->{fasta}/$nameTag.fasta";
			my $cmdPath = "$weblogoDirHsh_ref->{cmd}/$nameTag.cmd";
			my $seqType = 'dna';
			my $title = "cleavageSite $polyATypeTag N=$numGene";
			&createWeblogo($seqAlignHsh_ref, $pdfPath, $fastaPath, $cmdPath, $seqType, $title);#->1845
		}
		
		if ($polyATypeTag eq 's_tail') {
			my ($baseCompByPosHsh_ref, undef, undef, undef) = &calculateBaseCompositionInAlignments($seqAlignHsh_ref);#->762
			my $baseComHsh_ref = $baseCompByPosHsh_ref;
			my $bkgrndNtPercentHsh_ref = $clstrSeqBaseProportionHsh_ref->{'s_tail'};#---[14/10/2013 14:51] nulceotide frequence of the sites around all s_tail polyA cluster
			my $motifFilePath = "$resultMotifDir/s_tail.CSE.motif.txt";
			&createMotifFileFromBaseComposition($bkgrndNtPercentHsh_ref, $baseComHsh_ref, $motifFilePath);#->1811
		}
	}
	
	return ();
}
sub generateDREMECmd {
#....................................................................................................................................................#
#	subroutineCategory: thridPartyApp
#	dependOnSub: >none
#	appearInSub: countMotifOccurenceInCDSWithShortAndLongCisNAT|1642, dremeATGssTAAasMotif|1979, dremePolyASiteMotif|2040
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $dremeMode, $dremeOutDir, $maxk, $minE, $mink, $negLogPath, $negSeqPath, $negativeAlignHsh_ref, $posSeqPath, $positiveAlignHsh_ref, $shuffleLogPath
#	output: $dremeOutputHsh_ref
#	toCall: my ($dremeOutputHsh_ref) = &generateDREMECmd($positiveAlignHsh_ref, $negativeAlignHsh_ref, $posSeqPath, $negSeqPath, $dremeOutDir, $shuffleLogPath, $negLogPath, $maxk, $mink, $minE, $dremeMode);
#	calledInLine: 1752, 2022, 2118
#....................................................................................................................................................#

	my ($positiveAlignHsh_ref, $negativeAlignHsh_ref, $posSeqPath, $negSeqPath, $dremeOutDir, $shuffleLogPath, $negLogPath, $maxk, $mink, $minE, $dremeMode) = @_;
	
	my $tmpDataInfoHsh_ref = {};
	$tmpDataInfoHsh_ref->{'pos'}{'hsh_ref'} = $positiveAlignHsh_ref;
	$tmpDataInfoHsh_ref->{'pos'}{'path'} = $posSeqPath;
	$tmpDataInfoHsh_ref->{'neg'}{'hsh_ref'} = $negativeAlignHsh_ref;
	$tmpDataInfoHsh_ref->{'neg'}{'path'} = $negSeqPath;
	
	foreach my $posOrNeg (keys %{$tmpDataInfoHsh_ref}) {
		my $seqPath = $tmpDataInfoHsh_ref->{$posOrNeg}{'path'};
		my $seqAlignHsh_ref = $tmpDataInfoHsh_ref->{$posOrNeg}{'hsh_ref'};
		open (SEQ, ">", $seqPath);
		foreach my $seqName (keys %{$seqAlignHsh_ref}) {
			next if $seqAlignHsh_ref->{$seqName} =~ m/[^ATGCatgc]/;
			print SEQ ">".$seqName."\n";
			print SEQ $seqAlignHsh_ref->{$seqName}."\n";
		}
		close SEQ;
	}
	
	my $dremeOutputHsh_ref = {};
	my @shuffleOrNegativeAry = ();
	push @shuffleOrNegativeAry, 'shuffle' if $dremeMode eq 'shuffle' or $dremeMode eq 'both';
	push @shuffleOrNegativeAry, 'negative' if $dremeMode eq 'negative' or $dremeMode eq 'both';
	
	foreach my $shuffleOrNegative (@shuffleOrNegativeAry) {
		my $dremeOutSubDir = "$dremeOutDir/$shuffleOrNegative/"; system ("mkdir -pm 777 $dremeOutSubDir");
		$dremeOutputHsh_ref->{$shuffleOrNegative}{'dir'} = $dremeOutSubDir;
		my $cmd = "dreme -norc -oc $dremeOutSubDir -p $tmpDataInfoHsh_ref->{'pos'}{'path'} -maxk $maxk -mink $mink -e $minE";
		my $log = $shuffleLogPath;
		if ($shuffleOrNegative eq 'negative') {
			$log = $negLogPath;
			$cmd .= " -n $tmpDataInfoHsh_ref->{'neg'}{'path'} "
		}
		$cmd .= " &>$log";
		$dremeOutputHsh_ref->{$shuffleOrNegative}{'cmd'} = $cmd;
		$dremeOutputHsh_ref->{$shuffleOrNegative}{'xml'} = "$dremeOutSubDir/dreme.xml";
		$dremeOutputHsh_ref->{$shuffleOrNegative}{'txt'} = "$dremeOutSubDir/dreme.txt";
		$dremeOutputHsh_ref->{$shuffleOrNegative}{'html'} = "$dremeOutSubDir/dreme.html";
	}
	
	return ($dremeOutputHsh_ref);
}
sub generateDSEAndPASMotifFileFromDremeTxt {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	secondaryAppearInSection: >none
#	input: $polyADremePathHsh_ref, $resultMotifDir
#	output: 
#	toCall: &generateDSEAndPASMotifFileFromDremeTxt($polyADremePathHsh_ref, $resultMotifDir);
#	calledInLine: 339
#....................................................................................................................................................#
	my ($polyADremePathHsh_ref, $resultMotifDir) = @_;
	
	foreach my $regionType (keys %{$polyADremePathHsh_ref}) {
		#---[14/10/2013 17:20]  will only the s_tail motif
		foreach my $shuffleOrNegative (keys %{$polyADremePathHsh_ref->{$regionType}{'s_tail'}{'txt'}}) {
			my $dremeTxtPath = $polyADremePathHsh_ref->{$regionType}{'s_tail'}{'txt'}{$shuffleOrNegative};
			open DREMETXT, "<", "$dremeTxtPath";
			open MOTIFTXT, ">", "$resultMotifDir/s_tail.$regionType.$shuffleOrNegative.motif.txt";
			my $motifNum = 0;
			while (<DREMETXT>) {
				$motifNum++ if $_ =~ m/^MOTIF/;
				if ($motifNum <= 1) {#---[14/10/2013 17:20]  only get the 1st motif
					print MOTIFTXT $_ ;
				} else {
					last;
				}
			}
			close DREMETXT;
			close MOTIFTXT;
		}
	}

	return ();
}
sub generateGeneByCntgHsh {
#....................................................................................................................................................#
#	subroutineCategory: gff
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref
#	output: $geneByCntgHsh_ref
#	toCall: my ($geneByCntgHsh_ref) = &generateGeneByCntgHsh($geneInfoHsh_ref);
#	calledInLine: 217
#....................................................................................................................................................#
	my ($geneInfoHsh_ref) = @_;
	
	&reportStatus("Generating geneByCntgHsh", 0, "\n");#->4806

	my $geneByCntgHsh_ref = {};
	$geneByCntgHsh_ref->{$geneInfoHsh_ref->{$_}{'cntg'}}{$_}++ foreach (keys %{$geneInfoHsh_ref});

	return ($geneByCntgHsh_ref);
}
sub generateThreadHshWithRandomCntg {
#....................................................................................................................................................#
#	subroutineCategory: multithread
#	dependOnSub: >none
#	appearInSub: checkOverlapAndProximity|987, clusterPolyASites|1334, countCtgryOnCntg|1521, getCoverageOfItemRngType_multiStrand|2627, getUTR3AndCDSPosCov|3212
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $cntgAry_ref, $threadToSpawn
#	output: $randCntgInThreadHsh_ref
#	toCall: my ($randCntgInThreadHsh_ref) = &generateThreadHshWithRandomCntg($threadToSpawn, $cntgAry_ref);
#	calledInLine: 1025, 1348, 1546, 2641, 3226
#....................................................................................................................................................#

	my ($threadToSpawn, $cntgAry_ref) = @_;

	my @shuffleCntgAry = shuffle(@{$cntgAry_ref});
	my $threadNum = 1;
	my $randCntgInThreadHsh_ref = {};
	foreach my $cntg (@{$cntgAry_ref}) {
		$threadNum = 1 if $threadNum > $threadToSpawn;
		push @{$randCntgInThreadHsh_ref->{$threadNum}}, $cntg;
		$threadNum++;
	}
	
	return $randCntgInThreadHsh_ref;

}
sub getClstrSequence {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: reportStatus|4806
#	appearInSub: printClusterInfoAndWig|4232
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 10_gatherAndReportPolyAInfo|320
#	input: $clstrInfoHsh_ref, $clstrSeqRng, $fastaHsh_ref
#	output: 
#	toCall: &getClstrSequence($clstrInfoHsh_ref, $fastaHsh_ref, $clstrSeqRng);
#	calledInLine: 4246
#....................................................................................................................................................#
	my ($clstrInfoHsh_ref, $fastaHsh_ref, $clstrSeqRng) = @_;

	&reportStatus("Getting sequences around polyA clusters", 10, "\n");#->4806
	
	foreach my $clstrID (keys %{$clstrInfoHsh_ref}) {
		my $cntg = $clstrInfoHsh_ref->{$clstrID}{'cntg'};
		my $strnd = $clstrInfoHsh_ref->{$clstrID}{'strnd'};
		my $peakPos = $clstrInfoHsh_ref->{$clstrID}{'peakPos'};
		$clstrInfoHsh_ref->{$clstrID}{'upStrmSeq'} = 'incomplete';
		$clstrInfoHsh_ref->{$clstrID}{'dnStrmSeq'} = 'incomplete';

		my $upStrmSeq = my $dnStrmSeq = '';
		if ($strnd eq '+') {
			$upStrmSeq = substr $fastaHsh_ref->{$cntg}, $peakPos-$clstrSeqRng, $clstrSeqRng;
			$dnStrmSeq = substr $fastaHsh_ref->{$cntg}, $peakPos, $clstrSeqRng;
		} else {
			$upStrmSeq = substr $fastaHsh_ref->{$cntg}, $peakPos-1, $clstrSeqRng;
			$dnStrmSeq = substr $fastaHsh_ref->{$cntg}, $peakPos-$clstrSeqRng-1, $clstrSeqRng;
			$upStrmSeq = reverse $upStrmSeq;
			$dnStrmSeq = reverse $dnStrmSeq;
			$upStrmSeq =~ tr/ACGTacgt/TGCAtgca/;
			$dnStrmSeq =~ tr/ACGTacgt/TGCAtgca/;
		}
		
		$clstrInfoHsh_ref->{$clstrID}{'upStrmSeq'} = $upStrmSeq if (length $upStrmSeq == $clstrSeqRng and $upStrmSeq !~ m/N/gi);
		$clstrInfoHsh_ref->{$clstrID}{'dnStrmSeq'} = $dnStrmSeq if (length $dnStrmSeq == $clstrSeqRng and $dnStrmSeq !~ m/N/gi);
	}

	return ();
}
sub getCoverageOfItemRngType_multiStrand {
#....................................................................................................................................................#
#	subroutineCategory: coverage
#	dependOnSub: generateThreadHshWithRandomCntg|2558, reportStatus|4806
#	appearInSub: getValidPolyASiteDistribution|3344
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 7_plotRawDistribution|276
#	input: $dirtnAry_ref, $itemByCntgHsh_ref, $itemInfoHsh_ref, $margin, $maxThread, $pileupStorablePathHsh_ref, $rngType
#	output: $covHsh_ref
#	toCall: my ($covHsh_ref) = &getCoverageOfItemRngType_multiStrand($pileupStorablePathHsh_ref, $itemInfoHsh_ref, $itemByCntgHsh_ref, $maxThread, $rngType, $margin, $dirtnAry_ref);
#	calledInLine: 3371
#....................................................................................................................................................#
	my ($pileupStorablePathHsh_ref, $itemInfoHsh_ref, $itemByCntgHsh_ref, $maxThread, $rngType, $margin, $dirtnAry_ref) = @_;
	
	my @cntgAry = (keys %{$pileupStorablePathHsh_ref});
	my $randCntgInThreadHsh_ref = &generateThreadHshWithRandomCntg($maxThread, \@cntgAry);#->2558
	my $cntgProc :shared = 0;
	my %threadHsh = ();

	my %strndCovToGetHsh = ();

	$strndCovToGetHsh{'+'}{'s'} = '+';
	$strndCovToGetHsh{'+'}{'a'} = '-';
	$strndCovToGetHsh{'-'}{'s'} = '-';
	$strndCovToGetHsh{'-'}{'a'} = '+';

	foreach my $threadNum (sort {$a <=> $b} keys %{$randCntgInThreadHsh_ref}) {
		my $cntgAry_ref = \@{$randCntgInThreadHsh_ref->{$threadNum}};
		my $cntgNum = @{$randCntgInThreadHsh_ref->{$threadNum}};
		&reportStatus("$cntgNum cntgs spawned to thread $threadNum", 20, "\r");#->4806

		#---spawn a new thread
		($threadHsh{$threadNum}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781
		
			sub {
				my ($cntgAry_ref) = @_;
				my $covInThrHsh_ref = {};
				foreach my $cntg (@{$cntgAry_ref}) {
					$cntgProc++;
					my $cntgCovAry_ref = retrieve($pileupStorablePathHsh_ref->{$cntg});
					next if not exists $itemByCntgHsh_ref->{$cntg};
					foreach my $itemID (keys %{$itemByCntgHsh_ref->{$cntg}}) {
						next if not $itemInfoHsh_ref->{$itemID}{$rngType};

						my @rng = sort {$a <=> $b} @{$itemInfoHsh_ref->{$itemID}{$rngType}};
						unshift @rng, ($rng[0]-1-$margin, $rng[0]-1);
						push @rng, ($rng[-1]+1, $rng[-1]+1+$margin);
	
						my $posCovAry_ref = ();
						#my @deBugAry = ($itemID, $itemInfoHsh_ref->{$itemID}{'strnd'});
						for (my $i=0; $i < $#rng; $i += 2) {
							foreach my $j ($rng[$i]-1..$rng[$i+1]-1) {
								my $pos = $j + 1;
								my %tmpCovHsh = ('+'=>0, '-'=>0);
								#push @deBugAry, $j;
								($tmpCovHsh{'+'}, $tmpCovHsh{'-'}) = split /,/, $cntgCovAry_ref->[$pos] if ($cntgCovAry_ref->[$pos]);
								foreach my $dirtn (@{$dirtnAry_ref}) {
									push @{$posCovAry_ref->{$dirtn}}, $tmpCovHsh{$strndCovToGetHsh{$itemInfoHsh_ref->{$itemID}{'strnd'}}{$dirtn}};
								}
							}
						}

						#print $FHDebugLog join "", (join "\t", (@deBugAry)), "\n";
	
						foreach my $dirtn (@{$dirtnAry_ref}) {
							if ($itemInfoHsh_ref->{$itemID}{'strnd'} eq '-') {
								@{$covInThrHsh_ref->{$itemID}{$dirtn}} = reverse @{$posCovAry_ref->{$dirtn}};
							} else {
								@{$covInThrHsh_ref->{$itemID}{$dirtn}} = @{$posCovAry_ref->{$dirtn}};
							}
						}
					}
					
					&reportStatus("Finished counting items on $cntgProc cntg", 20, "\r");#->4806
				}
				return ($covInThrHsh_ref);
			}
			,($cntgAry_ref)
		);
	}
	
	my $covHsh_ref = {};
	
	while (keys %threadHsh) {
		foreach my $threadNum (keys %threadHsh) {
			my $thr = $threadHsh{$threadNum};
			if (not $thr->is_running()) {
				my ($covInThrHsh_ref) = $thr->join;
				foreach my $itemID (keys %{$covInThrHsh_ref}) {
					foreach my $dirtn (keys %{$covInThrHsh_ref->{$itemID}}) {
						$covHsh_ref->{$itemID}{$dirtn} = $covInThrHsh_ref->{$itemID}{$dirtn};
					}
				}
				delete $threadHsh{$threadNum};
				undef $covInThrHsh_ref;
			}
		}
		sleep 1;
	}

	my $numItem = scalar(keys %{$covHsh_ref});
	my $dirtnStr = join " & ", @{$dirtnAry_ref};
	&reportStatus("$rngType coverage of $numItem items in $dirtnStr direction were stored", 10, "\n");#->4806
	
	return ($covHsh_ref);

}
sub getCtgryGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|1872
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $ctgryAry_ref, $geneInfoHsh_ref
#	output: $geneCtgryByCntgHsh_ref, $geneCtgryInfoHsh_ref
#	toCall: my ($geneCtgryInfoHsh_ref, $geneCtgryByCntgHsh_ref) = &getCtgryGeneInfo($geneInfoHsh_ref, $ctgryAry_ref);
#	calledInLine: 219
#....................................................................................................................................................#

	my ($geneInfoHsh_ref, $ctgryAry_ref) = @_;
	
	my $geneCtgryInfoHsh_ref = {};
	my $geneCtgryByCntgHsh_ref = {};
	
	my $ctgryStr = join ",", @{$ctgryAry_ref};

	print "[".&currentTime()."] Filtering GFF on ctgry $ctgryStr.\n";#->1872
	
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my $ctgry = $geneInfoHsh_ref->{$geneID}{'ctgry'};
		my $cntg = $geneInfoHsh_ref->{$geneID}{'cntg'};
		if (grep /^$ctgry$/, @{$ctgryAry_ref}) {
			%{$geneCtgryInfoHsh_ref->{$geneID}} = %{$geneInfoHsh_ref->{$geneID}};
			$geneCtgryByCntgHsh_ref->{$cntg}{$geneID}++;
		}
	}
	
	my $numGene = keys %{$geneCtgryInfoHsh_ref};
	
	print "[".&currentTime()."] $numGene gene filtered on ctgry $ctgryStr.\n";#->1872
	
	return ($geneCtgryInfoHsh_ref, $geneCtgryByCntgHsh_ref);
}
sub getEnd3SequenceForCDSWithLongAndShortNAT {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: getSeqOfItemRngType|3144, reportStatus|4806
#	appearInSub: countMotifOccurenceInCDSWithShortAndLongCisNAT|1642
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $cisNATTypeHsh_ref, $end3RegionSize, $fastaHsh_ref, $mRNAInfoHsh_ref
#	output: $revcomCDSEnd3SeqHsh_ref
#	toCall: my ($revcomCDSEnd3SeqHsh_ref) = &getEnd3SequenceForCDSWithLongAndShortNAT($cisNATTypeHsh_ref, $mRNAInfoHsh_ref, $fastaHsh_ref, $end3RegionSize);
#	calledInLine: 1662
#....................................................................................................................................................#
	my ($cisNATTypeHsh_ref, $mRNAInfoHsh_ref, $fastaHsh_ref, $end3RegionSize) = @_;
	
	my $revcomCDSEnd3SeqHsh_ref = {};
	
	my @randNoNATmRNAIDAry = shuffle(keys %{$cisNATTypeHsh_ref->{'noNAT'}});
	my @randEnd3OtherNATmRNAIDAry = shuffle(keys %{$cisNATTypeHsh_ref->{'end3OtherNAT'}});
	my $startIndex = 0; #---[16/10/2013 19:22] to make sure randCntrl mRNA are not overlapping
	
	my $itemInfoHsh_ref = $mRNAInfoHsh_ref;
	my $margin= 0;
	my $rngType = "CDSRng";

	foreach my $NAType (qw/end3LongNAT end3ShortNAT/) {
		my $numGene = keys %{$cisNATTypeHsh_ref->{$NAType}};
		
		#---[16/10/2013 19:28] generate random mRNAID for control
		my $randCntrlmRNAIDHsh_ref = {};
		foreach my $i (1..$numGene) {
			$randCntrlmRNAIDHsh_ref->{'randCntrlNoNAT'}{$randNoNATmRNAIDAry[$startIndex+$i]}++;
			$randCntrlmRNAIDHsh_ref->{'randCntrlEnd3OtherNAT'}{$randEnd3OtherNATmRNAIDAry[$startIndex+$i]}++;
		}
		$startIndex += $numGene;
		my $mRNAFullSeqHsh_ref = {};
		$mRNAFullSeqHsh_ref->{'qry'} = &getSeqOfItemRngType($fastaHsh_ref, $itemInfoHsh_ref, $rngType, $margin, $cisNATTypeHsh_ref->{$NAType});#->3144
		$mRNAFullSeqHsh_ref->{'randCntrlNoNAT'} = &getSeqOfItemRngType($fastaHsh_ref, $itemInfoHsh_ref, $rngType, $margin, $randCntrlmRNAIDHsh_ref->{'randCntrlNoNAT'});#->3144
		$mRNAFullSeqHsh_ref->{'randCntrlEnd3OtherNAT'} = &getSeqOfItemRngType($fastaHsh_ref, $itemInfoHsh_ref, $rngType, $margin, $randCntrlmRNAIDHsh_ref->{'randCntrlEnd3OtherNAT'});#->3144
		
		&reportStatus("$numGene sequence stored for $NAType", 10, "\n");#->4806

		foreach my $qryOrCntl (keys %{$mRNAFullSeqHsh_ref}) {
			foreach my $mRNAID (keys %{$mRNAFullSeqHsh_ref->{$qryOrCntl}}) {
				my $revcomEnd3Seq = substr $mRNAFullSeqHsh_ref->{$qryOrCntl}{$mRNAID}, -1*$end3RegionSize;
				$revcomEnd3Seq = reverse $revcomEnd3Seq;
				$revcomEnd3Seq =~ tr/ACGTacgt/TGCAtgca/;
				$revcomCDSEnd3SeqHsh_ref->{$NAType}{$qryOrCntl}{$mRNAID} = $revcomEnd3Seq;
			}
		}
	}

	return ($revcomCDSEnd3SeqHsh_ref);
}
sub getIndivCntgCovPlsPath {
#....................................................................................................................................................#
#	subroutineCategory: storable
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 5_getValidPolyASitesAndPlotRawDistribution|245
#	secondaryAppearInSection: >none
#	input: $cntgCovPlsIndexPath
#	output: $cntgCovInPlsPathHsh_ref
#	toCall: my ($cntgCovInPlsPathHsh_ref) = &getIndivCntgCovPlsPath($cntgCovPlsIndexPath);
#	calledInLine: 257
#....................................................................................................................................................#
	
	my ($cntgCovPlsIndexPath) = @_;

	$cntgCovPlsIndexPath =~ s/\.gz$//;

	my $cntgCovInPlsPathHsh_ref = {};
	
	system ("gzip -fd $cntgCovPlsIndexPath.gz") if -s "$cntgCovPlsIndexPath.gz";
	my %plsIndexHsh = %{retrieve($cntgCovPlsIndexPath)};
	
	my (undef, $cntgCovStroableDir, undef) = fileparse($cntgCovPlsIndexPath, qr/\.[^.]*/);
	foreach my $cntg (keys %plsIndexHsh) {
		my $cntgCovPlsPath = "$cntgCovStroableDir/$plsIndexHsh{$cntg}";
		die "cntgCovPlsPath $cntgCovPlsPath is invalid\n" if ((not -s $cntgCovPlsPath) and (not -s $cntgCovPlsPath.".gz"));
		$cntgCovInPlsPathHsh_ref->{$cntg} = $cntgCovPlsPath;
	}
	my $numCntg = keys %{$cntgCovInPlsPathHsh_ref};
	&reportStatus("pls path of $numCntg contig stored", 20, "\n");#->4806
	
	return $cntgCovInPlsPathHsh_ref;
}
sub getIntergenicDistanceAndCDSLength {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: ggplotHistogram|3444, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $ggplotDirHsh_ref, $hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir
#	output: $CDSLengthPctHsh_ref, $intGenicDistPctHsh_ref
#	toCall: my ($intGenicDistPctHsh_ref, $CDSLengthPctHsh_ref) = &getIntergenicDistanceAndCDSLength($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $ggplotDirHsh_ref, $resultStorableDir);
#	calledInLine: 222
#....................................................................................................................................................#
	my ($hitAndPrxmtyBymRNAHsh_ref, $mRNAInfoHsh_ref, $ggplotDirHsh_ref, $resultStorableDir) = @_;
	
	my $intGenicDistPctHsh_ref = {};
	my $CDSLengthPctHsh_ref = {};
	my $intGenicDistPctHshPlsPath = "$resultStorableDir/intGenicDistPctHsh.pls";
	my $CDSLengthPctHshPlsPath = "$resultStorableDir/CDSLengthPctHsh.pls";
	
	if (-s $CDSLengthPctHshPlsPath and -s $intGenicDistPctHshPlsPath) {
		&reportStatus("Retrieving intergenic distance and CDS length", 10, "\n");#->4806

		$intGenicDistPctHsh_ref = retrieve($intGenicDistPctHshPlsPath);
		$CDSLengthPctHsh_ref = retrieve($CDSLengthPctHshPlsPath);
		
	} else {
	
		&reportStatus("Analyzing intergenic distance and CDS length", 10, "\n");#->4806
		my $dirTag = "geneInfo";
		system ("mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$dirTag/") foreach (keys %{$ggplotDirHsh_ref});
		my $intGenicDistAry_ref = ();
		my $CDSLengthAry_ref = ();
		my $numGene = 0;
		foreach my $mRNAID (keys %{$mRNAInfoHsh_ref}) {
		
			#--exclude any gene that is overlapping with anything
			next if ($hitAndPrxmtyBymRNAHsh_ref->{'XS'}{'hit'}{$mRNAID});
			$numGene++;

			my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
			my $CDSLength = 0;
			for (my $i=0; $i < $#CDSRngAry; $i += 2) {
				$CDSLength += $CDSRngAry[$i+1]-$CDSRngAry[$i];
			}
			push @{$CDSLengthAry_ref}, $CDSLength;

			foreach my $HOrT (keys %{$hitAndPrxmtyBymRNAHsh_ref->{'XS'}{'prxmty'}{$mRNAID}}) {
				my ($prxmtyDist, $prxmtyID) = @{$hitAndPrxmtyBymRNAHsh_ref->{'XS'}{'prxmty'}{$mRNAID}{$HOrT}};
				push @{$intGenicDistAry_ref}, $prxmtyDist if $prxmtyDist > 0;
			}
		}

		my %tmpHshAryRefHsh = ();
		$tmpHshAryRefHsh{'CDSLength'}{'aryRef'} = $CDSLengthAry_ref;
		$tmpHshAryRefHsh{'CDSLength'}{'pctHshRef'} = $CDSLengthPctHsh_ref;
		$tmpHshAryRefHsh{'intGenicDist'}{'aryRef'} = $intGenicDistAry_ref;
		$tmpHshAryRefHsh{'intGenicDist'}{'pctHshRef'} = $intGenicDistPctHsh_ref;

		foreach my $CDSLengthOrIntGenicDist (keys %tmpHshAryRefHsh) {

			my $plotAry_ref = $tmpHshAryRefHsh{$CDSLengthOrIntGenicDist}{'aryRef'};
			my $valueStatObj = Statistics::Descriptive::Full->new();
			$valueStatObj->add_data(@{$plotAry_ref});
			foreach my $pct (qw/1 5 10 25 50 65 75 85 90 95 97 99/) {
				$tmpHshAryRefHsh{$CDSLengthOrIntGenicDist}{'pctHshRef'}->{$pct} = $valueStatObj->percentile($pct);
			}

			my $nameTag = "$CDSLengthOrIntGenicDist.histogram";
			my $dataPath = "$ggplotDirHsh_ref->{'dat'}/$dirTag/$nameTag.dat";
			my $pdfPath = "$ggplotDirHsh_ref->{'pdf'}/$dirTag/$nameTag.pdf";
			my $RScriptPath = "$ggplotDirHsh_ref->{'R'}/$dirTag/$nameTag.R";
			my $logPath = "$ggplotDirHsh_ref->{'log'}/$dirTag/$nameTag.log";
			my $leftXAxisPercentileLimit = 'min';
			my $rightXAxisPercentileLimit = 99;
			my $XAxis = $CDSLengthOrIntGenicDist;
			my $binWidth = 10;
			my $extraArg = " + ggtitle(\"N=$numGene $CDSLengthOrIntGenicDist\") + scale_fill_gradient(\"count\", low = \"grey\", high = \"red\")";
			foreach my $pct (keys %{$tmpHshAryRefHsh{$CDSLengthOrIntGenicDist}{'pctHshRef'}}) {
				$extraArg .= " + geom_vline(xintercept=c($tmpHshAryRefHsh{$CDSLengthOrIntGenicDist}{'pctHshRef'}->{$pct}), linetype=\"dotted\") + annotate(\"text\", x=$tmpHshAryRefHsh{$CDSLengthOrIntGenicDist}{'pctHshRef'}->{$pct}, y=0, label=\"$pct %\=$tmpHshAryRefHsh{$CDSLengthOrIntGenicDist}{'pctHshRef'}->{$pct}\", vjust=-0.2, hjust=-0.1, angle=90)";
			}
			my $log2OrLinear = 'linear';#-----choose the value to be plot in linear or log2 scale here
			my $dataPtMax = 99999999;
			my $height = 8;
			my $width = 24;
			&ggplotHistogram($plotAry_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear, $height, $width);#->3444
		}
	
		$intGenicDistPctHsh_ref = $tmpHshAryRefHsh{'intGenicDist'}{'pctHshRef'};
		$CDSLengthPctHsh_ref = $tmpHshAryRefHsh{'CDSLength'}{'pctHshRef'};
		
		store($intGenicDistPctHsh_ref, $intGenicDistPctHshPlsPath);
		store($CDSLengthPctHsh_ref, $CDSLengthPctHshPlsPath);
	}

	return ($intGenicDistPctHsh_ref, $CDSLengthPctHsh_ref);
}
sub getNonStructuralCount {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: countCtgryOnCntg|1521
#	appearInSub: >none
#	primaryAppearInSection: 6_filterAbovebackgroundPolyASites|263
#	secondaryAppearInSection: >none
#	input: $controlPileupPlsPathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir, $validPolyASitePlsPathHsh_ref
#	output: $nonStructuralCountHsh_ref
#	toCall: my ($nonStructuralCountHsh_ref) = &getNonStructuralCount($validPolyASitePlsPathHsh_ref, $controlPileupPlsPathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir);
#	calledInLine: 271
#....................................................................................................................................................#
	my ($validPolyASitePlsPathHsh_ref, $controlPileupPlsPathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir) = @_;
	
	my $nonStructuralCountHsh_ref = {};
	foreach my $nameTag (qw/polyA control/) {
		my $margin5End = my $margin3End = 0;
		my $pileupStorablePathHsh_ref;
		if ($nameTag eq "polyA") {$pileupStorablePathHsh_ref = $validPolyASitePlsPathHsh_ref;} 
		else {$pileupStorablePathHsh_ref = $controlPileupPlsPathHsh_ref;}
		(undef, undef, $nonStructuralCountHsh_ref->{$nameTag}) = &countCtgryOnCntg($pileupStorablePathHsh_ref, $geneByCntgHsh_ref, $geneInfoHsh_ref, $maxThread, $resultStorableDir, $margin5End, $margin3End, $nameTag);#->1521
	}
	return ($nonStructuralCountHsh_ref);
}
sub getRawPolyASite {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: createEmptyGenomeCovPerlStorable|1770, printWigFromCovPerlStorable|4474, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 5_getValidPolyASitesAndPlotRawDistribution|245
#	secondaryAppearInSection: >none
#	input: $IGVGenomePath, $fastaHsh_ref, $polyACntgPosAvgTailLenHshPlsPath, $resultStorableDir, $resultWigDir
#	output: $polyATailLenPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref
#	toCall: my ($rawPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref) = &getRawPolyASite($polyACntgPosAvgTailLenHshPlsPath, $fastaHsh_ref, $resultStorableDir, $IGVGenomePath, $resultWigDir);
#	calledInLine: 252
#....................................................................................................................................................#
	my ($polyACntgPosAvgTailLenHshPlsPath, $fastaHsh_ref, $resultStorableDir, $IGVGenomePath, $resultWigDir) = @_;
	
	my $rawPolyASitePlsPathHshPlsPath = "$resultStorableDir/rawPolyASitePlsPathHsh.pls";
	my $rawPolyASitePlsPathHsh_ref = {};
	my $polyATailLenPlsPathHshPlsPath = "$resultStorableDir/polyATailLenPlsPathHsh.pls";
	my $polyATailLenPlsPathHsh_ref = {};

	&reportStatus("Getting raw polyA sites", 10, "\n");#->4806
	
	if (-s $rawPolyASitePlsPathHshPlsPath and -s $polyATailLenPlsPathHshPlsPath) {
	
		&reportStatus("Retrieving rawPolyASitePlsPathHsh", 10, "\n");#->4806
		$rawPolyASitePlsPathHsh_ref = retrieve($rawPolyASitePlsPathHshPlsPath);
		$polyATailLenPlsPathHsh_ref = retrieve($polyATailLenPlsPathHshPlsPath);

	} else {

		my $polyASitePlsDir = "$resultStorableDir/rawPolyASiteCntg/";
		($rawPolyASitePlsPathHsh_ref) = &createEmptyGenomeCovPerlStorable($polyASitePlsDir, $fastaHsh_ref);#->1770

		my $polyATailLenPlsDir = "$resultStorableDir/polyATailLenCntg/";
		($polyATailLenPlsPathHsh_ref) = &createEmptyGenomeCovPerlStorable($polyATailLenPlsDir, $fastaHsh_ref);#->1770

		&reportStatus("Retrieving polyACntgPosAvgTailLenHsh", 50, "\n");#->4806
		my $polyACntgPosAvgTailLenHsh_ref = retrieve($polyACntgPosAvgTailLenHshPlsPath);

		foreach my $cntg (sort keys %{$polyACntgPosAvgTailLenHsh_ref}) {
		
			&reportStatus("Getting raw polyA sites on $cntg", 10, "\r");#->4806
			my %tmpCntgAryRefHsh = ();
			
			$tmpCntgAryRefHsh{'num'} = retrieve($rawPolyASitePlsPathHsh_ref->{$cntg});
			$tmpCntgAryRefHsh{'ALen'} = retrieve($polyATailLenPlsPathHsh_ref->{$cntg});
			
			foreach my $pos (sort {$a <=> $b} keys %{$polyACntgPosAvgTailLenHsh_ref->{$cntg}}) {
				my $i = $pos - 1;
				my %tmpCovHsh = ();
				$tmpCovHsh{'num'}{'+'} = $tmpCovHsh{'num'}{'-'} = $tmpCovHsh{'ALen'}{'+'} = $tmpCovHsh{'ALen'}{'-'} = 0;
				foreach my $strnd (keys %{$polyACntgPosAvgTailLenHsh_ref->{$cntg}{$pos}}) {
					foreach my $numOrALen (keys %{$polyACntgPosAvgTailLenHsh_ref->{$cntg}{$pos}{$strnd}}) {
						$tmpCovHsh{$numOrALen}{$strnd} = $polyACntgPosAvgTailLenHsh_ref->{$cntg}{$pos}{$strnd}{$numOrALen};
					}
				}
				$tmpCntgAryRefHsh{$_}->[$i] = join ",", ($tmpCovHsh{$_}{'+'}, $tmpCovHsh{$_}{'-'}) foreach (keys %tmpCovHsh);
			}
			
			store($tmpCntgAryRefHsh{'num'}, $rawPolyASitePlsPathHsh_ref->{$cntg});
			store($tmpCntgAryRefHsh{'ALen'}, $polyATailLenPlsPathHsh_ref->{$cntg});
		}
		
		&printWigFromCovPerlStorable($rawPolyASitePlsPathHsh_ref, "$resultWigDir/raw.polyA.num", $IGVGenomePath);#->4474
		&printWigFromCovPerlStorable($polyATailLenPlsPathHsh_ref, "$resultWigDir/raw.polyA.ALen", $IGVGenomePath);#->4474
		store($rawPolyASitePlsPathHsh_ref, $rawPolyASitePlsPathHshPlsPath);
		store($polyATailLenPlsPathHsh_ref, $polyATailLenPlsPathHshPlsPath);
	}
	
	return ($rawPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref);
}
sub getSenseTailPolyASiteDistribution {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: ggplotHistogram|3444, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 7_plotRawDistribution|276
#	secondaryAppearInSection: >none
#	input: $ggplotDirHsh_ref, $initialOutterBound, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir, $validPolyASitePlsPathHsh_ref
#	output: $senseTailPolyAPctHsh_ref
#	toCall: my ($senseTailPolyAPctHsh_ref) = &getSenseTailPolyASiteDistribution($mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $initialOutterBound, $validPolyASitePlsPathHsh_ref, $ggplotDirHsh_ref, $resultStorableDir);
#	calledInLine: 282
#....................................................................................................................................................#
	my ($mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $initialOutterBound, $validPolyASitePlsPathHsh_ref, $ggplotDirHsh_ref, $resultStorableDir) = @_;
	
	my $senseTailPolyAPctHsh_ref = {};
	my $senseTailPolyAPctHshPlsPath = "$resultStorableDir/senseTailPolyAPctHsh.pls";

	if (-s $senseTailPolyAPctHshPlsPath) {
		
		&reportStatus("Retrieving senseTailPolyAPctHsh", 20, "\n");#->4806
		$senseTailPolyAPctHsh_ref = retrieve($senseTailPolyAPctHshPlsPath);
	
	} else {
	
		my $dirTag = "sensePolyATail";
		system ("mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$dirTag/") foreach (keys %{$ggplotDirHsh_ref});

		&reportStatus('Getting PolyA Site Distribution at sense tail', 10, "\n");#->4806
	
		my $senseTailPolyADstrbtnAry_ref = ();
		my $polyASiteCountHsh_ref = ();
		my $numPolyASite = 0;
	
		foreach my $cntg (keys %{$mRNAByCntgHsh_ref}) {
			my $cntgCovAry_ref = retrieve($validPolyASitePlsPathHsh_ref->{$cntg});
			next if not exists $mRNAByCntgHsh_ref->{$cntg};
			foreach my $mRNAID (keys %{$mRNAByCntgHsh_ref->{$cntg}}) {
				my @CDSRngAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
				my @srchRng = ();
				if ($mRNAInfoHsh_ref->{$mRNAID}{'strnd'} eq '+') {
					@srchRng = ($CDSRngAry[-1]..$CDSRngAry[-1]+$initialOutterBound);
				} else {
					@srchRng = reverse ($CDSRngAry[0]-$initialOutterBound-1..$CDSRngAry[0]);
				}
				
				my $rltvPos = 0;
				foreach my $pos (@srchRng) {
					my $i = $pos -1;
					$rltvPos++;
					if ($cntgCovAry_ref->[$i]) {
						my %tmpCovHsh = ();
						($tmpCovHsh{'+'}, $tmpCovHsh{'-'}) = split /,/, $cntgCovAry_ref->[$i];
						if ($tmpCovHsh{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}} > 0) {
							push @{$senseTailPolyADstrbtnAry_ref}, $rltvPos;
							$polyASiteCountHsh_ref->{$mRNAID}++;
							$numPolyASite++;
						}
					}
				}
			}
		}
	
		my $numGene = keys %{$polyASiteCountHsh_ref};
		my $sitePerGene = sprintf "%.2f", $numPolyASite/$numGene;
	
		my $plotAry_ref = $senseTailPolyADstrbtnAry_ref;
		my $sensePolyATailFStatObj = Statistics::Descriptive::Full->new();
		$sensePolyATailFStatObj->add_data(@{$plotAry_ref});
		foreach my $pct (qw/1 5 10 25 50 65 75 85 90 95 97 99/) {
			$senseTailPolyAPctHsh_ref->{$pct} = $sensePolyATailFStatObj->percentile($pct);
		}

		my $nameTag = "valid.polyASite.dstrbtn";
		my $dataPath = "$ggplotDirHsh_ref->{'dat'}/$dirTag/$nameTag.dat";
		my $pdfPath = "$ggplotDirHsh_ref->{'pdf'}/$dirTag/$nameTag.pdf";
		my $RScriptPath = "$ggplotDirHsh_ref->{'R'}/$dirTag/$nameTag.R";
		my $logPath = "$ggplotDirHsh_ref->{'log'}/$dirTag/$nameTag.log";
		my $leftXAxisPercentileLimit = 'min';
		my $rightXAxisPercentileLimit = 'max';
		my $XAxis = "rltvPosFromStopCodon";
		my $binWidth = 1;
		my $extraArg = " + ggtitle(\"N=$numGene sitePerGene=$sitePerGene\") + scale_fill_gradient(\"count\", low = \"grey\", high = \"red\")";
		foreach my $pct (keys %{$senseTailPolyAPctHsh_ref}) {
			$extraArg .= " + geom_vline(xintercept=c($senseTailPolyAPctHsh_ref->{$pct}), linetype=\"dotted\") + annotate(\"text\", x=$senseTailPolyAPctHsh_ref->{$pct}, y=0, label=\"$pct %\=$senseTailPolyAPctHsh_ref->{$pct}\", vjust=-0.2, hjust=-0.1, angle=90)";
		}
		my $log2OrLinear = 'linear';#-----choose the value to be plot in linear or log2 scale here
		my $dataPtMax = 99999999;
		my $height = 8;
		my $width = 24;
		&ggplotHistogram($plotAry_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear, $height, $width);#->3444
		
		store($senseTailPolyAPctHsh_ref, $senseTailPolyAPctHshPlsPath);

	}
	
	return ($senseTailPolyAPctHsh_ref);
}
sub getSeqOfItemRngType {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportStatus|4806
#	appearInSub: getEnd3SequenceForCDSWithLongAndShortNAT|2771, getmRNASeqWithEnd3AntisensePolyA|3379
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $fastaHsh_ref, $itemFilterHsh_ref, $itemInfoHsh_ref, $margin, $rngType
#	output: $itemSeqHsh_ref
#	toCall: my ($itemSeqHsh_ref) = &getSeqOfItemRngType($fastaHsh_ref, $itemInfoHsh_ref, $rngType, $margin, $itemFilterHsh_ref);
#	calledInLine: 2805, 2806, 2807, 3420
#....................................................................................................................................................#
	my ($fastaHsh_ref, $itemInfoHsh_ref, $rngType, $margin, $itemFilterHsh_ref) = @_;
	
	my $itemSeqHsh_ref = {};
	my $numItemProc = 0;
	my $numItemTotal = (keys %{$itemInfoHsh_ref});

	foreach my $itemID (sort keys %{$itemInfoHsh_ref}) {
		my $recordSeq = 'no';
		
		$numItemProc++;
		
		next if not $itemFilterHsh_ref->{$itemID};
	
		my @rng = sort {$a <=> $b} @{$itemInfoHsh_ref->{$itemID}{$rngType}};

		if ($margin > 0) {#----extending the margin
			unshift @rng, ($rng[0]-1-$margin, $rng[0]-1);
			push @rng, ($rng[-1]+1, $rng[-1]+1+$margin);
		}
			
		my $itemSeq = '';
		if ($rng[-1] < length $fastaHsh_ref->{$itemInfoHsh_ref->{$itemID}{'cntg'}}) {

			$recordSeq = 'yes';

			for (my $i=0; $i < $#rng; $i += 2) {
				my $startIndex = $rng[$i]-1;
				my $endIndex = $rng[$i+1]-1;
				$itemSeq .= substr $fastaHsh_ref->{$itemInfoHsh_ref->{$itemID}{'cntg'}}, $startIndex, $endIndex-$startIndex+1;
			}
	
			if ($itemInfoHsh_ref->{$itemID}{'strnd'} eq '-') {
				$itemSeq = reverse $itemSeq;
				$itemSeq =~ tr/ACGTacgt/TGCAtgca/;
			}
		
			if ($margin < 0) {
				if (length $itemSeq > -2*$margin) {
					$recordSeq = 'yes';
					$itemSeq = substr $itemSeq, -1*$margin, $margin; #----trim the margin
				} else {
					$recordSeq = 'no';
				}
			}
		
			if ($recordSeq eq 'yes') {
				$itemSeqHsh_ref->{$itemID} = $itemSeq;
			}
		}
		
		&reportStatus("Processed sequences in $numItemProc of $numItemTotal items ", 20, "\r");#->4806
	}
	
	return ($itemSeqHsh_ref);

}
sub getUTR3AndCDSPosCov {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: FHLock|451, FHUnlock|468, generateThreadHshWithRandomCntg|2558, reportStatus|4806
#	appearInSub: trainingUsingCDSVsUTR3|4829
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 6_filterAbovebackgroundPolyASites|263
#	input: $CDSNumPosPerGene, $controlPileupPlsPathHsh_ref, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $margin, $maxThread, $rawPolyASitePlsPathHsh_ref
#	output: $covPairHsh_ref
#	toCall: my ($covPairHsh_ref) = &getUTR3AndCDSPosCov($controlPileupPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $maxThread, $margin, $CDSNumPosPerGene);
#	calledInLine: 4853
#....................................................................................................................................................#
	my ($controlPileupPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $maxThread, $margin, $CDSNumPosPerGene) = @_;
	
	my @cntgAry = (keys %{$rawPolyASitePlsPathHsh_ref});
	my $randCntgInThreadHsh_ref = &generateThreadHshWithRandomCntg($maxThread, \@cntgAry);#->2558
	my $cntgProc :shared = 0;
	my %threadHsh = ();
	
	foreach my $threadNum (sort {$a <=> $b} keys %{$randCntgInThreadHsh_ref}) {
		my $cntgAry_ref = \@{$randCntgInThreadHsh_ref->{$threadNum}};
		my $cntgNum = @{$randCntgInThreadHsh_ref->{$threadNum}};
		&reportStatus("$cntgNum cntgs spawned to thread $threadNum", 20, "\r");#->4806

		#---spawn a new thread
		($threadHsh{$threadNum}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781
		
			sub {
				my ($cntgAry_ref) = @_;
				
				my $covPair_inThr_Hsh_ref = {};
				
				foreach my $cntg (@{$cntgAry_ref}) {
					$cntgProc++;
					next if not exists $mRNAByCntgHsh_ref->{$cntg};

					my %tmpCntgCovAryHsh = ();
					$tmpCntgCovAryHsh{'polyA'} = retrieve($rawPolyASitePlsPathHsh_ref->{$cntg});
					$tmpCntgCovAryHsh{'control'} = retrieve($controlPileupPlsPathHsh_ref->{$cntg});
					
					foreach my $mRNAID (keys %{$mRNAByCntgHsh_ref->{$cntg}}) {
						next if not $mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'};
						
						#---get the UTR3 ranges
						my @CDSRngBoundAry = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
						my @UTR3PosAry = ();
						if ($mRNAInfoHsh_ref->{$mRNAID}{'strnd'} eq '+') {
							@UTR3PosAry = ($CDSRngBoundAry[-1]+1..$CDSRngBoundAry[-1]+1+$margin);
						} else {
							@UTR3PosAry = ($CDSRngBoundAry[0]-1-$margin..$CDSRngBoundAry[0]-1);
						}
						
						#---check polyA count in UTR3 rng
						my $maxPolyACountUTR3 = 0;
						my $maxPolyAPosUTR3 = 0;
						foreach my $pos (@UTR3PosAry) {
							my $i = $pos-1;
							my %tmpCovHsh = ('+'=>0, '-'=>0);
							($tmpCovHsh{'+'}, $tmpCovHsh{'-'}) = split /,/, $tmpCntgCovAryHsh{'polyA'}->[$i] if $tmpCntgCovAryHsh{'polyA'}->[$i];
							if ($tmpCovHsh{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}} > $maxPolyACountUTR3) {
								$maxPolyACountUTR3 = $tmpCovHsh{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}};
								$maxPolyAPosUTR3 = $pos;
							}
						}
						
						#---get the value pairs
						if ($maxPolyACountUTR3 > 0) {
							
							my %tmpPosHsh = ();
							
							#---generate UTR3 pos ary
							@{$tmpPosHsh{'UTR3'}} = ($maxPolyAPosUTR3);
							
							#---generate random CDS pos ary
							my @CDSPosAry = ();
							for (my $i=0; $i < $#CDSRngBoundAry; $i += 2) {
								push @CDSPosAry, ($CDSRngBoundAry[$i]-1..$CDSRngBoundAry[$i+1]-1);
							}
							push @{$tmpPosHsh{'CDS'}}, shuffle(@CDSPosAry);

							foreach my $CDSOrUTR3 (keys %tmpPosHsh) {
								my $posSampled = 0;
								foreach my $pos (@{$tmpPosHsh{$CDSOrUTR3}}) {
									my $i = $pos-1;
									my %tmpValuePairHsh = ();
									foreach my $polyAOrControl (keys %tmpCntgCovAryHsh) {
										my %tmpCovHsh = ('+'=>0, '-'=>0);
										($tmpCovHsh{'+'}, $tmpCovHsh{'-'}) = split /,/, $tmpCntgCovAryHsh{$polyAOrControl}->[$i] if $tmpCntgCovAryHsh{$polyAOrControl}->[$i];
										$tmpValuePairHsh{$polyAOrControl} = $tmpCovHsh{$mRNAInfoHsh_ref->{$mRNAID}{'strnd'}};
									}
									
									if ($tmpValuePairHsh{'polyA'} > 0) {
										if ($CDSOrUTR3 eq 'CDS') {
											$posSampled++;
											last if $posSampled > $CDSNumPosPerGene;
										}
									
										#&FHLock($FHDebugLog);#->451
										#print $FHDebugLog join "\t", ($mRNAID, $CDSOrUTR3, $cntg.":".$pos, $tmpValuePairHsh{'polyA'}, $tmpValuePairHsh{'control'}."\n");
										#&FHUnlock($FHDebugLog);#->468
										push @{$covPair_inThr_Hsh_ref->{$CDSOrUTR3}}, join ",", ($tmpValuePairHsh{'polyA'}, $tmpValuePairHsh{'control'});
									}
								}
							}
						}
					}
					
					&reportStatus("Finished counting items on $cntgProc cntg", 20, "\r");#->4806
				}
				return ($covPair_inThr_Hsh_ref);
			}
			,($cntgAry_ref)
		);
	}
	
	my $covPairHsh_ref = {};
	
	while (keys %threadHsh) {
		foreach my $threadNum (keys %threadHsh) {
			my $thr = $threadHsh{$threadNum};
			if (not $thr->is_running()) {
				my ($covPair_inThr_Hsh_ref) = $thr->join;
				foreach my $CDSOrUTR3 (keys %{$covPair_inThr_Hsh_ref}) {
					push @{$covPairHsh_ref->{$CDSOrUTR3}}, @{$covPair_inThr_Hsh_ref->{$CDSOrUTR3}};
				}
				delete $threadHsh{$threadNum};
			}
		}
		sleep 1;
	}
	return ($covPairHsh_ref);
}
sub getValidPolyASiteDistribution {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: getCoverageOfItemRngType_multiStrand|2627, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 7_plotRawDistribution|276
#	secondaryAppearInSection: >none
#	input: $initialOutterBound, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $maxThread, $resultStorableDir, $validPolyASitePlsPathHsh_ref
#	output: $validPolyASiteDstrbtnHsh_ref
#	toCall: my ($validPolyASiteDstrbtnHsh_ref) = &getValidPolyASiteDistribution($validPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $initialOutterBound, $maxThread, $resultStorableDir);
#	calledInLine: 281
#....................................................................................................................................................#
	my ($validPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $initialOutterBound, $maxThread, $resultStorableDir) = @_;
	
	my $validPolyASiteDstrbtnHsh_ref = {};
	my $validPolyASiteDstrbtnHshPlsPath = "$resultStorableDir/validPolyASiteDstrbtnHsh.pls";
	if (-s $validPolyASiteDstrbtnHshPlsPath) {
		&reportStatus("Retrieving validPolyASiteDstrbtnHsh", 10, "\n");#->4806
		$validPolyASiteDstrbtnHsh_ref = retrieve($validPolyASiteDstrbtnHshPlsPath);
		
	} else {

		my $margin = $initialOutterBound;
		my $itemByCntgHsh_ref = $mRNAByCntgHsh_ref;
		my $itemInfoHsh_ref = $mRNAInfoHsh_ref;
		my $rngType = 'CDSRng';
		my $pileupStorablePathHsh_ref = $validPolyASitePlsPathHsh_ref;
		my @dirtnAry = qw/a s/;
		($validPolyASiteDstrbtnHsh_ref) = &getCoverageOfItemRngType_multiStrand($pileupStorablePathHsh_ref, $itemInfoHsh_ref, $itemByCntgHsh_ref, $maxThread, $rngType, $margin, \@dirtnAry);#->2627

		store($validPolyASiteDstrbtnHsh_ref, $validPolyASiteDstrbtnHshPlsPath);
	}

	return ($validPolyASiteDstrbtnHsh_ref);
}
sub getmRNASeqWithEnd3AntisensePolyA {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: getSeqOfItemRngType|3144, printBothFHAndStdout|4176, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	secondaryAppearInSection: >none
#	input: $FH_paramValueLog, $end3ASPolyARng, $fastaHsh_ref, $initialOutterBound, $mRNAGeneBodyPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir
#	output: $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $mRNAIDWithEnd3ASPolyAHsh_ref
#	toCall: my ($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $mRNAIDWithEnd3ASPolyAHsh_ref) = &getmRNASeqWithEnd3AntisensePolyA($mRNAGeneBodyPolyAInfoHsh_ref, $initialOutterBound, $end3ASPolyARng, $fastaHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir, $FH_paramValueLog);
#	calledInLine: 352
#....................................................................................................................................................#
	my ($mRNAGeneBodyPolyAInfoHsh_ref, $initialOutterBound, $end3ASPolyARng, $fastaHsh_ref, $mRNAInfoHsh_ref, $resultStorableDir, $FH_paramValueLog) = @_;
	
	my $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref = {};
	my $mRNAHeadTailSeqWithEnd3ASPolyAHshPlsPath = "$resultStorableDir/mRNAHeadTailSeqWithEnd3ASPolyAHsh.pls";
	my $mRNAIDWithEnd3ASPolyAHsh_ref = {};
	my $mRNAIDWithEnd3ASPolyAHshPlsPath = "$resultStorableDir/mRNAIDWithEnd3ASPolyAHsh.pls";
	
	if (-s $mRNAHeadTailSeqWithEnd3ASPolyAHshPlsPath and -s $mRNAIDWithEnd3ASPolyAHshPlsPath) {
		
		&reportStatus("Retrieving mRNAHeadTailSeqWithEnd3ASPolyAHshPlsPath",20 ,"\n");#->4806
		$mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref = retrieve($mRNAHeadTailSeqWithEnd3ASPolyAHshPlsPath);
		$mRNAIDWithEnd3ASPolyAHsh_ref = retrieve($mRNAIDWithEnd3ASPolyAHshPlsPath);
		
	} else {
		
		&reportStatus("Getting mRNA with antisense poly A site at 3 end",20 ,"\n");#->4806
		foreach my $mRNAID (keys %{$mRNAGeneBodyPolyAInfoHsh_ref->{'a'}}) {
			foreach my $clstrID (keys %{$mRNAGeneBodyPolyAInfoHsh_ref->{'a'}{$mRNAID}}) {
				
				#---[05/10/2013 17:54] $distFromCDSEnd if a negetive value referenced to TAA
				my $distFromCDSEnd = $mRNAGeneBodyPolyAInfoHsh_ref->{'a'}{$mRNAID}{$clstrID}{'distFromCDSEnd'};
				$mRNAIDWithEnd3ASPolyAHsh_ref->{$mRNAID}++ if (abs $distFromCDSEnd) <= $end3ASPolyARng;
			}
		}
	
		#---get the full sequence
		my $margin= -10;
		my $itemFilterHsh_ref = $mRNAIDWithEnd3ASPolyAHsh_ref;
		my $itemInfoHsh_ref = $mRNAInfoHsh_ref;
		my $rngType = "CDSRng";
		my ($mRNAFullSeqWithEnd3ASPolyAHsh_ref) = &getSeqOfItemRngType($fastaHsh_ref, $itemInfoHsh_ref, $rngType, $margin, $itemFilterHsh_ref);#->3144
		
		#---get head and tail sequence
		foreach my $mRNAID (sort keys %{$mRNAFullSeqWithEnd3ASPolyAHsh_ref}) {
			
			next if length $mRNAFullSeqWithEnd3ASPolyAHsh_ref->{$mRNAID} < $end3ASPolyARng;
		
			$mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'headSSSeq'}{$mRNAID} = substr $mRNAFullSeqWithEnd3ASPolyAHsh_ref->{$mRNAID}, 0, $end3ASPolyARng+$margin;
			$mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'tailASSeq'}{$mRNAID} = substr $mRNAFullSeqWithEnd3ASPolyAHsh_ref->{$mRNAID}, -1*($end3ASPolyARng+$margin);
			$mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'tailASSeq'}{$mRNAID} = reverse $mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'tailASSeq'}{$mRNAID};
			$mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref->{'tailASSeq'}{$mRNAID} =~ tr/ACGTacgt/TGCAtgca/;
		}
		
		store($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $mRNAHeadTailSeqWithEnd3ASPolyAHshPlsPath);
		store($mRNAIDWithEnd3ASPolyAHsh_ref, $mRNAIDWithEnd3ASPolyAHshPlsPath);
	}
	
	my $mRNAWithEnd3ASPolyA = keys %{$mRNAIDWithEnd3ASPolyAHsh_ref};
	&printBothFHAndStdout("mRNAWithEnd3ASPolyA = $mRNAWithEnd3ASPolyA", 40, $FH_paramValueLog);#->4176
	
	return ($mRNAHeadTailSeqWithEnd3ASPolyAHsh_ref, $mRNAIDWithEnd3ASPolyAHsh_ref);
	
}
sub ggplotHistogram {
#....................................................................................................................................................#
#	subroutineCategory: ggplot, plotInR
#	dependOnSub: >none
#	appearInSub: getIntergenicDistanceAndCDSLength|2857, getSenseTailPolyASiteDistribution|3047
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 4_processGenomeInformation|209, 7_plotRawDistribution|276
#	input: $RScriptPath, $XAxis, $binWidth, $dataPath, $dataPtMax, $extraArg, $height, $leftXAxisPercentileLimit, $log2OrLinear, $logPath, $pdfPath, $plotAry_ref, $rightXAxisPercentileLimit, $width
#	output: $plotValueAry_ref
#	toCall: my ($plotValueAry_ref) = &ggplotHistogram($plotAry_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear, $height, $width);
#	calledInLine: 2940, 3135
#....................................................................................................................................................#
	
	my ($plotAry_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear, $height, $width) = @_;
	
	my $valueStatObj = Statistics::Descriptive::Full->new();
	$valueStatObj->add_data(@{$plotAry_ref});

	my $leftXAxisLimitValue;
	if ($leftXAxisPercentileLimit eq 'min') {
		$leftXAxisLimitValue = $valueStatObj->min();
	} else {
		$leftXAxisLimitValue = $valueStatObj->percentile($leftXAxisPercentileLimit);
	}

	my $rightXAxisLimitValue;
	if ($rightXAxisPercentileLimit eq 'max') {
		$rightXAxisLimitValue = $valueStatObj->max();
	} else {
		$rightXAxisLimitValue = $valueStatObj->percentile($rightXAxisPercentileLimit);
	}
	
	#---trim the end values
	my @trimmedAry = ();
	foreach my $value (@{$plotAry_ref}) {
		my $transformedValue = $value;
		if ($log2OrLinear eq 'log2') {
			$transformedValue = 0;
			eval {$transformedValue = log($value)/log(2)};
		}
		push @trimmedAry, $transformedValue if $value <= $rightXAxisLimitValue and $value >= $leftXAxisLimitValue;
	}
	
	$dataPtMax = @trimmedAry if $dataPtMax > @trimmedAry;

	#---down sample the data point number
	my @shuffleIndexAry = shuffle(0..$#trimmedAry);
	my $plotValueAry_ref = ();
	
	open (PLOTDATA, ">", $dataPath);
	print PLOTDATA $XAxis."\n";
	foreach my $i (0..$dataPtMax-1) {
		my $shuffleValue = $trimmedAry[$shuffleIndexAry[$i]];
		push @{$plotValueAry_ref}, $shuffleValue;
		print PLOTDATA $shuffleValue."\n";
		
	}
	close PLOTDATA;
	
	open (R, ">", $RScriptPath);
	print R "library(ggplot2)"."\n";
	print R "dataFrame = read.table(file=\"$dataPath\", header=TRUE)"."\n";
	print R "ggplot(dataFrame, aes(x=$XAxis)) + ggtitle(\"Distribution of $XAxis $log2OrLinear scale [n=$dataPtMax]\") + geom_histogram(binwidth=$binWidth, aes(y = ..density.., fill = ..count..)) + geom_density() $extraArg"."\n";
	print R "ggsave(file=\"$pdfPath\", height=$height, width=$width)\n";
	close R;
	
	system ("R --slave --vanilla --file=$RScriptPath &>$logPath ");

	return $plotValueAry_ref;
	
}
sub ggplotMultiSampleHistogram {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: plotCDSToUTR3Ratio|3801
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $RScriptPath, $XAxis, $binWidth, $dataPath, $dataPtMax, $extraArg, $leftXAxisPercentileLimit, $log2OrLinear, $logPath, $pdfPath, $plotAryHsh_ref, $rightXAxisPercentileLimit
#	output: none
#	toCall: &ggplotMultiSampleHistogram($plotAryHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear);
#	calledInLine: 3860
#....................................................................................................................................................#

	my ($plotAryHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear) = @_;
	
	open (PLOTDATA, ">", $dataPath);
	print PLOTDATA "sample\t$XAxis\n";

	foreach my $sample (keys %{$plotAryHsh_ref}) {
		
		my $plotAry_ref = $plotAryHsh_ref->{$sample};
	
		my $valueStatObj = Statistics::Descriptive::Full->new();
		$valueStatObj->add_data(@{$plotAry_ref});

		my $leftXAxisLimitValue;
		if ($leftXAxisPercentileLimit eq 'min') {
			$leftXAxisLimitValue = $valueStatObj->min();
		} else {
			$leftXAxisLimitValue = $valueStatObj->percentile($leftXAxisPercentileLimit);
		}

		my $rightXAxisLimitValue;
		if ($rightXAxisPercentileLimit eq 'max') {
			$rightXAxisLimitValue = $valueStatObj->max();
		} else {
			$rightXAxisLimitValue = $valueStatObj->percentile($rightXAxisPercentileLimit);
		}
	
		#---trim the end values
		my @trimmedAry = ();
		foreach my $value (@{$plotAry_ref}) {
			my $transformedValue = $value;
			if ($value > 0) {
				eval {$transformedValue = log($value)/log(2) if $log2OrLinear eq 'log2';};
				push @trimmedAry, $transformedValue if $value <= $rightXAxisLimitValue and $value >= $leftXAxisLimitValue;
			}
		}
		
		my $indivDataPtMax = $dataPtMax;
		$indivDataPtMax = @trimmedAry if $indivDataPtMax > @trimmedAry;

		#---down sample the data point number
		my @shuffleIndexAry = shuffle(0..$#trimmedAry);
		foreach my $i (0..$indivDataPtMax-1) {
			my $shuffleValue = $trimmedAry[$shuffleIndexAry[$i]];
			print PLOTDATA "$sample\t$shuffleValue\n";
		}
	
	}
	close PLOTDATA;

	open (R, ">", $RScriptPath);
	print R "library(ggplot2)"."\n";
	print R "dataFrame = read.table(file=\"$dataPath\", header=TRUE)"."\n";
	print R "ggplot(dataFrame, aes($XAxis, fill = sample)) + ggtitle(\"Distribution of $XAxis $log2OrLinear scale\") + geom_density(alpha = 0.2) $extraArg"."\n";
	print R "ggsave(file=\"$pdfPath\")\n";
	close R;
	
	system ("R --slave --vanilla --file=$RScriptPath &>$logPath ");

}
sub ggplotXYLineSingleSample {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: optimizeGapSizeAndClstrPolyASites|3657, plotCoverageAroundGene|3867
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 8_findOptimalGapSizeAndClusterPolyASites|290
#	input: $RScriptPath, $XAXis, $YAxis, $dataPath, $extraArg, $extraStatment, $height, $logPath, $pdfPath, $plotDataHsh_ref, $width
#	output: 
#	toCall: &ggplotXYLineSingleSample($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $extraArg, $extraStatment, $height, $width);
#	calledInLine: 3738, 4040
#....................................................................................................................................................#

	my ($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $extraArg, $extraStatment, $height, $width) = @_;
	
	open (PLOTDATA, ">", $dataPath);
	print PLOTDATA join "", (join "\t", ($XAXis, $YAxis)), "\n";
	foreach my $XVal (sort {$a <=> $b} keys %{$plotDataHsh_ref}) {
		my $YVal = $plotDataHsh_ref->{$XVal};
		print PLOTDATA join "", (join "\t", ($XVal, $YVal)), "\n";
	}
	close PLOTDATA;

	open (R, ">", $RScriptPath);
	print R "library(ggplot2)"."\n";
	print R "$extraStatment"."\n";
	print R "dataFrame = read.table(file=\"$dataPath\", header=TRUE)"."\n";
	print R "ggplot(dataFrame, aes(x=$XAXis, y=$YAxis)) + geom_line() $extraArg"."\n";
	print R "ggsave(file=\"$pdfPath\", height=$height, width=$width)\n";
	close R;
	
	system ("R --slave --vanilla --file=$RScriptPath &>$logPath");
	
	return ();
}
sub ggplotXYLinesMultipleSamples {
#....................................................................................................................................................#
#	subroutineCategory: ggplot, plotInR
#	dependOnSub: >none
#	appearInSub: calculatePolyAOccurenceWithinCDSOnBothStrand|815, plotBaseCompositionClstrPeak|3750
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 10_gatherAndReportPolyAInfo|320, 11_investigatePolyAClstrMotif|333
#	input: $RScriptPath, $XAXis, $YAxis, $YVariable, $dataPath, $extraArg, $height, $logPath, $pdfPath, $plotDataHsh_ref, $width
#	output: none
#	toCall: &ggplotXYLinesMultipleSamples($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $YVariable, $extraArg, $height, $width);
#	calledInLine: 882, 3794
#....................................................................................................................................................#

	my ($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $YVariable, $extraArg, $height, $width) = @_;
	
	open (PLOTDATA, ">", $dataPath);
	print PLOTDATA join "", (join "\t", ($YVariable, $YAxis, $XAXis)), "\n";
	foreach my $YCategory (sort keys %{$plotDataHsh_ref}) {
		foreach my $XVal (sort {$a <=> $b} keys %{$plotDataHsh_ref->{$YCategory}}) {
			my $YVal = $plotDataHsh_ref->{$YCategory}{$XVal};
			print PLOTDATA join "", (join "\t", ($YCategory, $YVal, $XVal)), "\n";
		}
	}
	close PLOTDATA;

	open (R, ">", $RScriptPath);
	print R "library(ggplot2)"."\n";
	print R "dataFrame = read.table(file=\"$dataPath\", header=TRUE)"."\n";
	print R "ggplot(dataFrame, aes(x=$XAXis, y=$YAxis, colour=$YVariable)) + geom_line() $extraArg"."\n";
	print R "ggsave(file=\"$pdfPath\", height=$height, width=$width)\n";
	close R;
	
	system ("R --slave --vanilla --file=$RScriptPath &>$logPath");

}
sub optimizeGapSizeAndClstrPolyASites {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: clusterPolyASites|1334, ggplotXYLineSingleSample|3587, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 8_findOptimalGapSizeAndClusterPolyASites|290
#	secondaryAppearInSection: >none
#	input: $ggplotDirHsh_ref, $maxThread, $polyATailLenPlsPathHsh_ref, $resultStorableDir, $validPolyASitePlsPathHsh_ref
#	output: $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref
#	toCall: my ($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref) = &optimizeGapSizeAndClstrPolyASites($maxThread, $validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $resultStorableDir, $ggplotDirHsh_ref);
#	calledInLine: 295
#....................................................................................................................................................#
	my ($maxThread, $validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $resultStorableDir, $ggplotDirHsh_ref) = @_;

	my $clstrInfoHshPlsPath = "$resultStorableDir/clstrInfoHsh.pls";
	my $clstrPeakByPosHshPlsPath = "$resultStorableDir/clstrPeakByPosHsh.pls";
	my $clstrInfoHsh_ref = {};
	my $clstrPeakByPosHsh_ref = {};
	
	if (-s $clstrInfoHshPlsPath and -s $clstrPeakByPosHshPlsPath) {

		&reportStatus("Retrieving clstrInfoHsh and clstrPeakByPosHsh", 30, "\n");#->4806
		$clstrInfoHsh_ref = retrieve($clstrInfoHshPlsPath);
		$clstrPeakByPosHsh_ref = retrieve($clstrPeakByPosHshPlsPath);
		
	} else {#---optimize the gap size
	
		my $plotTag = 'optimizeGapSize';
		system ("mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$plotTag/") foreach (keys %{$ggplotDirHsh_ref});
		
		my $gapSizeClstrStatHsh_ref = {};
		my $gapSizeClstrStatHshPlsPath = "$resultStorableDir/gapSizeClstrStatHsh.pls";
		my $minTestGapSize = 5;
		my $maxTestGapSize = 100;
		my $stepTestGapSize = 5;
		my $cutoffDiffInClstrPct = 0.5;#---when diffInClstrPct reaches cutoffDiffInClstrPct, the gapSize will be the optimal gap size

		if (-s $gapSizeClstrStatHshPlsPath) {
			&reportStatus("Retrieving gapSizeClstrStatHsh", 30, "\n");#->4806
			$gapSizeClstrStatHsh_ref = retrieve($gapSizeClstrStatHshPlsPath);
		} else {
			for (my $maxGapInClstr = $minTestGapSize; $maxGapInClstr <= $maxTestGapSize; $maxGapInClstr += $stepTestGapSize) {
				&reportStatus("Clustering polyA sites with $maxGapInClstr with $maxThread threads", 10, "\n");#->4806
				my (undef, $clstrStatHsh_ref, undef) = &clusterPolyASites($validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $maxGapInClstr, $maxThread, 'no');#->1334
				$gapSizeClstrStatHsh_ref->{$maxGapInClstr}{$_} = $clstrStatHsh_ref->{$_} foreach (keys %{$clstrStatHsh_ref});
			}
			store($gapSizeClstrStatHsh_ref, $gapSizeClstrStatHshPlsPath);
		}

		my %tmpPlotHsh = ();
		$tmpPlotHsh{'inClstrPct'}{'plotDataHsh_ref'} = {};
		$tmpPlotHsh{'diffInClstrPct'}{'plotDataHsh_ref'} = {};
	
		my $lastInClstrPct = 0;
		my $optimalMaxGapInClstr = $maxTestGapSize;
	
		foreach my $maxGapInClstr (sort {$a <=> $b} keys %{$gapSizeClstrStatHsh_ref}) {
			my $curntInClstrPct = $gapSizeClstrStatHsh_ref->{$maxGapInClstr}{'inClstrPct'};
			my $diffInClstrPct = $curntInClstrPct-$lastInClstrPct;
			if ($optimalMaxGapInClstr == $maxTestGapSize and $diffInClstrPct <= $cutoffDiffInClstrPct) {
				$optimalMaxGapInClstr = $maxGapInClstr;
			}
		
			$lastInClstrPct = $curntInClstrPct;
			$tmpPlotHsh{'inClstrPct'}{'plotDataHsh_ref'}->{$maxGapInClstr} = $curntInClstrPct;
			$tmpPlotHsh{'diffInClstrPct'}{'plotDataHsh_ref'}->{$maxGapInClstr} = $diffInClstrPct;
		}
	
		foreach my $diffInClstrPctOrInClstrPct (keys %tmpPlotHsh) {
			my $plotDataHsh_ref = $tmpPlotHsh{$diffInClstrPctOrInClstrPct}{'plotDataHsh_ref'};
			my $nameTag = "optmize.gapSize.vs.$diffInClstrPctOrInClstrPct";
			my $dataPath = $ggplotDirHsh_ref->{'dat'}."/$plotTag/$nameTag.dat";
			my $pdfPath = $ggplotDirHsh_ref->{'pdf'}."/$plotTag/$nameTag.pdf";
			my $RScriptPath = $ggplotDirHsh_ref->{'R'}."/$plotTag/$nameTag.R";
			my $logPath = $ggplotDirHsh_ref->{'log'}."/$plotTag/$nameTag.log";
			my $XAXis = 'maxGapInClstr';
			my $YAxis = $diffInClstrPctOrInClstrPct;
			my $extraStatment = "";
			my $extraArg = " + geom_vline(aes(xintercept = $optimalMaxGapInClstr), alpha=0.2, size=10, color=\"red\") + geom_point(aes(size = $YAxis, color=$YAxis)) + ggtitle(\"Optimize gap size within polyA clstr\") + scale_x_continuous(breaks=seq($minTestGapSize, $maxTestGapSize, by=2))";
			#my $extraArg = '';
			my $height = 8;
			my $width = 16;
			&ggplotXYLineSingleSample($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $extraArg, $extraStatment, $height, $width);#->3587
		}

		&reportStatus("Clustering polyA sites with optimal gap size at $optimalMaxGapInClstr", 10, "\n");#->4806
		($clstrInfoHsh_ref, undef, $clstrPeakByPosHsh_ref) = &clusterPolyASites($validPolyASitePlsPathHsh_ref, $polyATailLenPlsPathHsh_ref, $optimalMaxGapInClstr, $maxThread, 'yes');#->1334
		store($clstrInfoHsh_ref, $clstrInfoHshPlsPath);
		store($clstrPeakByPosHsh_ref, $clstrPeakByPosHshPlsPath);
	}
	
	return ($clstrInfoHsh_ref, $clstrPeakByPosHsh_ref);
}
sub plotBaseCompositionClstrPeak {
#....................................................................................................................................................#
#	subroutineCategory: baseComposition, ggplot
#	dependOnSub: calculateBaseCompositionInAlignments|762, ggplotXYLinesMultipleSamples|3622, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 11_investigatePolyAClstrMotif|333
#	secondaryAppearInSection: >none
#	input: $clstrSeqHsh_ref, $clstrSeqRng, $ggplotDirHsh_ref
#	output: $clstrSeqBaseProportionHsh_ref
#	toCall: my ($clstrSeqBaseProportionHsh_ref) = &plotBaseCompositionClstrPeak($clstrSeqHsh_ref, $ggplotDirHsh_ref, $clstrSeqRng);
#	calledInLine: 340
#....................................................................................................................................................#

	my ($clstrSeqHsh_ref, $ggplotDirHsh_ref, $clstrSeqRng) = @_;
	
	my $clstrSeqBaseProportionHsh_ref = {};
	my $seqLength = int(2*$clstrSeqRng);
	
	foreach my $polyATypeTag (sort keys %{$clstrSeqHsh_ref}) {
		
		my $sub_ggplotDir = "baseCompstn";
		system "mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$sub_ggplotDir/" foreach (keys %{$ggplotDirHsh_ref});
		
		&reportStatus("Plotting sequence compostion around $polyATypeTag clstr", 10, "\n");#->4806

		my $seqAlignHsh_ref = $clstrSeqHsh_ref->{$polyATypeTag};
		my $clstrNum = keys %{$seqAlignHsh_ref};
		my ($baseCompByPosHsh_ref, $baseCompByBaseHsh_ref, $baseCountByPosHsh_ref, $baseProportionHsh_ref) = &calculateBaseCompositionInAlignments($seqAlignHsh_ref);#->762
		
		$clstrSeqBaseProportionHsh_ref->{$polyATypeTag} = $baseProportionHsh_ref;
		
		{	
			my $title = "N=$clstrNum";
			my $item = $polyATypeTag;
			my $plotDataHsh_ref = $baseCompByBaseHsh_ref;
			my $dataPath = "$ggplotDirHsh_ref->{'dat'}/$sub_ggplotDir/$item.dat";
			my $pdfPath = "$ggplotDirHsh_ref->{'pdf'}/$sub_ggplotDir/$item.pdf";
			my $RScriptPath = "$ggplotDirHsh_ref->{'R'}/$sub_ggplotDir/$item.R";
			my $logPath = "$ggplotDirHsh_ref->{'log'}/$sub_ggplotDir/$item.log";
			my $XAXis = 'relativePositon';
			my $YAxis = 'proportion';
			my $YVariable = 'base';
			my $extraArg = "+ ggtitle (\"$title\") + ylim(0,1) + scale_x_continuous(breaks=seq(0, $seqLength, by=10))";
			my $height = 6;
			my $width = 14;
			&ggplotXYLinesMultipleSamples($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $YVariable, $extraArg, $height, $width);#->3622
		}
	}
	
	return ($clstrSeqBaseProportionHsh_ref);
}
sub plotCDSToUTR3Ratio {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: ggplotMultiSampleHistogram|3515, reportStatus|4806
#	appearInSub: trainingUsingCDSVsUTR3|4829
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 6_filterAbovebackgroundPolyASites|263
#	input: $abvBkgdPctCutoffHsh_ref, $covPairHsh_ref, $ggplotDirHsh_ref, $plotTag
#	output: $abvBkgdValCutoffHsh_ref, $dataPairTypeStatHsh_ref
#	toCall: my ($abvBkgdValCutoffHsh_ref, $dataPairTypeStatHsh_ref) = &plotCDSToUTR3Ratio($covPairHsh_ref, $ggplotDirHsh_ref, $abvBkgdPctCutoffHsh_ref, $plotTag);
#	calledInLine: 4857
#....................................................................................................................................................#
	my ($covPairHsh_ref, $ggplotDirHsh_ref, $abvBkgdPctCutoffHsh_ref, $plotTag) = @_;
	
	system ("mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$plotTag/") foreach (keys %{$ggplotDirHsh_ref});

	my $abvBkgdValCutoffHsh_ref = {};
	my $dataPairTypeStatHsh_ref = {};
	
	foreach my $dataType (keys %{$abvBkgdPctCutoffHsh_ref}) {
		my $plotAryHsh_ref = {};
		foreach my $CDSOrUTR3 (keys %{$covPairHsh_ref}) {
			my $numPairInCtgry = 0;
			my $numPairTotal = @{$covPairHsh_ref->{$CDSOrUTR3}};
			foreach (@{$covPairHsh_ref->{$CDSOrUTR3}}) {
				my ($polyAVal, $controlVal) = split /,/, $_;
				if ($controlVal > 0 and $dataType eq 'polyAToCntrlCountRatio') {
					$numPairInCtgry++;
					push @{$plotAryHsh_ref->{$CDSOrUTR3}}, sprintf "%.03f", $polyAVal/$controlVal;
				} elsif ($controlVal == 0 and $dataType eq 'polyACountWithZeroCntrl') {
					$numPairInCtgry++;
					push @{$plotAryHsh_ref->{$CDSOrUTR3}}, $polyAVal;
				}
			}
			my $pctInCtrgy = sprintf "%.01f", 100*($numPairInCtgry/$numPairTotal);
			$dataPairTypeStatHsh_ref->{$CDSOrUTR3}{'pct'}{$dataType} = $pctInCtrgy;
			$dataPairTypeStatHsh_ref->{$CDSOrUTR3}{'sum'} = $numPairTotal;
		}
		
		my $valueStatObj = Statistics::Descriptive::Full->new();
		$valueStatObj->add_data(@{$plotAryHsh_ref->{'CDS'}});
		$abvBkgdValCutoffHsh_ref->{'linear'}{$dataType} = $valueStatObj->percentile($abvBkgdPctCutoffHsh_ref->{$dataType});
		$abvBkgdValCutoffHsh_ref->{'log2'}{$dataType} = 0;
		eval{$abvBkgdValCutoffHsh_ref->{'log2'}{$dataType} = sprintf "%.03f", log($abvBkgdValCutoffHsh_ref->{'linear'}{$dataType})/log(2);};
		
		{
			&reportStatus("Plotting $dataType histogram", 20,"\n"); #->4806
			my $title = "CDS=".$dataPairTypeStatHsh_ref->{'CDS'}{'pct'}{$dataType}."% of ".$dataPairTypeStatHsh_ref->{'CDS'}{'sum'}." | UTR3=".$dataPairTypeStatHsh_ref->{'UTR3'}{'pct'}{$dataType}."% of ".$dataPairTypeStatHsh_ref->{'UTR3'}{'sum'};
			my $nameTag = "trainning.$dataType.histogram";
			my $dataPath = "$ggplotDirHsh_ref->{'dat'}/$plotTag/$nameTag.dat";
			my $pdfPath = "$ggplotDirHsh_ref->{'pdf'}/$plotTag/$nameTag.pdf";
			my $RScriptPath = "$ggplotDirHsh_ref->{'R'}/$plotTag/$nameTag.R";
			my $logPath = "$ggplotDirHsh_ref->{'log'}/$plotTag/$nameTag.log";
			my $leftXAxisPercentileLimit = 'min';
			my $rightXAxisPercentileLimit = 'max';
			my $binWidth = 1;
			my $log2OrLinear = 'log2';
			my $XAxis = "$log2OrLinear\_$dataType";
			my $extraArg = " + ggtitle (\"$title\") + geom_vline(xintercept=c($abvBkgdValCutoffHsh_ref->{$log2OrLinear}{$dataType}), linetype=\"dotted\") + annotate(\"text\", x=$abvBkgdValCutoffHsh_ref->{$log2OrLinear}{$dataType}, y=0, label=\"$abvBkgdPctCutoffHsh_ref->{$dataType}\%\=$abvBkgdValCutoffHsh_ref->{$log2OrLinear}{$dataType}\", vjust=-0.2, hjust=-0.1, angle=90)";
			my $dataPtMax = 10000;
			&ggplotMultiSampleHistogram($plotAryHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $leftXAxisPercentileLimit, $rightXAxisPercentileLimit, $XAxis, $binWidth, $dataPtMax, $extraArg, $log2OrLinear);#->3515
		}
	}

	return ($abvBkgdValCutoffHsh_ref, $dataPairTypeStatHsh_ref);
}
sub plotCoverageAroundGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: ggplotXYLineSingleSample|3587, reportStatus|4806
#	appearInSub: plotValidPolyASiteAroundGenes|4049
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 1_defineHardCodedParam|104, 7_plotRawDistribution|276
#	input: $countTypeToPlot, $covHsh_ref, $dirTag, $dirtnAry_ref, $filterShort, $ggplotDirHsh_ref, $innerBound, $itemFilterHsh_ref, $margin, $minTotalCov, $nonStructuralCount, $outterBound, $plotTag, $posCovLimit, $printIndivCovLog, $refPtAry_ref, $resultLogDir, $resultStorableDir
#	output: $rltvPosCovHshPathHsh_ref
#	toCall: my ($rltvPosCovHshPathHsh_ref) = &plotCoverageAroundGene($covHsh_ref, $margin, $innerBound, $outterBound, $ggplotDirHsh_ref, $nonStructuralCount, $plotTag, $dirTag, $countTypeToPlot, $posCovLimit, $minTotalCov, $resultStorableDir, $itemFilterHsh_ref, $refPtAry_ref, $dirtnAry_ref, $resultLogDir, $filterShort, $printIndivCovLog);
#	calledInLine: 4085, 4096
#....................................................................................................................................................#

	my ($covHsh_ref, $margin, $innerBound, $outterBound, $ggplotDirHsh_ref, $nonStructuralCount, $plotTag, $dirTag, $countTypeToPlot, $posCovLimit, $minTotalCov, $resultStorableDir, $itemFilterHsh_ref, $refPtAry_ref, $dirtnAry_ref, $resultLogDir, $filterShort, $printIndivCovLog) = @_;
	
	$filterShort = 'no' if not defined $filterShort;

	#$countTypeToPlot can be rawSum normalizedSum scaledCount proportion or all
	
	#---create individual dir
	system ("mkdir -pm 777 $ggplotDirHsh_ref->{$_}/$dirTag/") foreach (keys %{$ggplotDirHsh_ref});
	system ("mkdir -pm 777 $resultLogDir/$dirTag/");
	system ("mkdir -pm 777 $resultStorableDir/$dirTag/");
	
	$outterBound = $margin if $outterBound > $margin;
	my $outterPosToTrim = $margin - $outterBound;
	
	my $rltvPosCovHshPathHsh_ref = {};
	
	foreach my $refPt (@{$refPtAry_ref}) {#---'head' and 'tail'
		foreach my $dirtn (@{$dirtnAry_ref}) {#---'a' and 's'
		
			my $rltvPosCovHshPath = "$resultStorableDir/$dirTag/$refPt.dirtn_$dirtn.$plotTag.rltvPosCovHsh.pls"; #---to be return out of the subroutine, can be further analysed for individual genes
			$rltvPosCovHshPathHsh_ref->{$dirtn}{$refPt} = $rltvPosCovHshPath;
			my $rltvPosCovHsh_ref = {};
			my $pooledPlotDataHsh_ref = {};
			my $pooledPlotDataHshPlsPath = "$resultStorableDir/$dirTag/$refPt.dirtn_$dirtn.$plotTag.pooledPlotDataHsh.pls";

			if (-s $pooledPlotDataHshPlsPath and -s $rltvPosCovHshPath) {
						
				&reportStatus("Skip Pooling coverage around $refPt in $dirtn direction for $plotTag", 10, "\n");#->4806

				$rltvPosCovHsh_ref = retrieve($rltvPosCovHshPath);
				$pooledPlotDataHsh_ref = retrieve($pooledPlotDataHshPlsPath);

			} else {
		
				my ($plotMinPos, $plotMaxPos);
				if ($refPt eq 'head') {
					$plotMinPos = -1*$outterBound;
					$plotMaxPos = $innerBound;
				} elsif ($refPt eq 'tail') {
					$plotMinPos = -1*$innerBound;
					$plotMaxPos = $outterBound;
				}
				
				my $numGene = 0;
				my $overallMaxPosCov = 0;
				my $pooledRltvPosGeneCountHsh_ref = {};

				#--set 0 in each rltvPos in each ctgry
				foreach my $rltvPos ($plotMinPos..$plotMaxPos) {
					$pooledPlotDataHsh_ref->{$_}{$rltvPos} = 0 foreach (qw/rawSum normalizedSum scaledCount proportion/);
				}

				my $xTick = nearest(50, abs($plotMaxPos-$plotMinPos)/20);

				&reportStatus("Pooling coverage around $refPt in $dirtn direction for $plotTag", 10, "\n");#->4806
				
				foreach my $itemID (keys %{$covHsh_ref}) {

					my $totalPosCov = 0;
					my $maxPosCov = 0;
					my @posCovAry = ();
					my $rltvPos;
			
					#---skip items that are too short
					if ($filterShort eq 'yes') {
						next if (@{$covHsh_ref->{$itemID}{$dirtn}} < ($outterBound*2)+$innerBound+1);
					}
				
					#---skip items is not in the list 
					next if not $itemFilterHsh_ref->{$itemID} and not $itemFilterHsh_ref->{'all'};
			
					if ($refPt eq 'head') {
						@posCovAry = @{$covHsh_ref->{$itemID}{$dirtn}};
						$rltvPos = -1*$outterBound;
					} elsif ($refPt eq 'tail') {
						@posCovAry = reverse @{$covHsh_ref->{$itemID}{$dirtn}};
						$rltvPos = $outterBound;
					}
			
					#---remove the pos in outter bound
					@posCovAry = @posCovAry[$outterPosToTrim..$#posCovAry];
		
					#---put data into plot hash
					my $indivPlotDataHsh_ref = {};
					foreach my $cov (@posCovAry[0..$outterBound+$innerBound-1]) {
						if ($refPt eq 'head') {$rltvPos++;} 
						elsif ($refPt eq 'tail') {$rltvPos--;}
						if (defined $cov) {
							$pooledRltvPosGeneCountHsh_ref->{$rltvPos}++;
						} else {#--- $rltvPos doesn't exist
							$cov = 0;
						}
						$totalPosCov += $cov;
						$indivPlotDataHsh_ref->{$rltvPos} = $cov;
						$maxPosCov = $cov if $cov > $maxPosCov;
					}

					if ($maxPosCov <= $posCovLimit and $totalPosCov >= $minTotalCov) {
						$numGene++;
						$overallMaxPosCov = $maxPosCov if $maxPosCov > $overallMaxPosCov;
						my $maxValue = max(values %{$indivPlotDataHsh_ref});
				
						foreach my $rltvPos (keys %{$indivPlotDataHsh_ref}) {
							if ($indivPlotDataHsh_ref->{$rltvPos} > 0) {
						
								$rltvPosCovHsh_ref->{$itemID}{$rltvPos} = $indivPlotDataHsh_ref->{$rltvPos};
						
								$pooledPlotDataHsh_ref->{'rawSum'}{$rltvPos} += $indivPlotDataHsh_ref->{$rltvPos};
								$pooledPlotDataHsh_ref->{'normalizedSum'}{$rltvPos} = $pooledPlotDataHsh_ref->{'rawSum'}{$rltvPos}/($nonStructuralCount/1000000);
								$pooledPlotDataHsh_ref->{'scaledCount'}{$rltvPos} += $indivPlotDataHsh_ref->{$rltvPos}/$maxValue; #---will be divided by number of genes at the end
								$pooledPlotDataHsh_ref->{'proportion'}{$rltvPos}++; #---will be divided by number of genes at the end
								$pooledPlotDataHsh_ref->{'frequency'}{$rltvPos}++; #---will be divided by number of genes at the end
							}
						}
					}
				}
				
				
				#---normalize using gene length
				foreach my $proportionOrScaledCount (qw/proportion scaledCount/) {
					foreach (keys %{$pooledPlotDataHsh_ref->{$proportionOrScaledCount}}) {
						if ($pooledPlotDataHsh_ref->{$proportionOrScaledCount}{$_} > 0) {
							$pooledPlotDataHsh_ref->{$proportionOrScaledCount}{$_} = $pooledPlotDataHsh_ref->{$proportionOrScaledCount}{$_}/$pooledRltvPosGeneCountHsh_ref->{$_};
						}
					}
				}
				
				store($rltvPosCovHsh_ref, $rltvPosCovHshPath);
				store($pooledPlotDataHsh_ref, $pooledPlotDataHshPlsPath);

				#---print the log file of coverage per gene
				if ($printIndivCovLog eq 'yes') {
					open COVLOG, ">", "$resultLogDir/$dirTag/$refPt.dirtn_$dirtn.$plotTag.xls";
					print COVLOG join "", ((join "\t", ('itemID', ($plotMinPos..$plotMaxPos))), "\n");
					foreach my $itemID (keys %{$rltvPosCovHsh_ref}) {
						my @outputAry = ($itemID);
						foreach my $rltvPos ($plotMinPos..$plotMaxPos) {
							my $cov = 0;
							$cov = $rltvPosCovHsh_ref->{$itemID}{$rltvPos} if $rltvPosCovHsh_ref->{$itemID}{$rltvPos};
							push @outputAry, $cov;
						}
						print COVLOG join "", ((join "\t", @outputAry), "\n");
					}
					close COVLOG;
				}
				
				#---plot the XY data
				foreach my $countType (keys %{$pooledPlotDataHsh_ref}) {
					next if $countTypeToPlot ne $countType and $countTypeToPlot ne 'all';
					my $plotDataHsh_ref = \%{$pooledPlotDataHsh_ref->{$countType}};
					my $nameTag = "$refPt.dirtn_$dirtn.$plotTag.$countType";
					my $dataPath = $ggplotDirHsh_ref->{'dat'}."/$dirTag/$nameTag.dat";
					my $pdfPath = $ggplotDirHsh_ref->{'pdf'}."/$dirTag/$nameTag.pdf";
					my $RScriptPath = $ggplotDirHsh_ref->{'R'}."/$dirTag/$nameTag.R";
					my $logPath = $ggplotDirHsh_ref->{'log'}."/$dirTag/$nameTag.log";
					my $XAXis = "distanceFrom_$refPt";
					my $YAxis = $countType;
					my $extraStatment = "";
					my $extraArg = " + geom_vline(xintercept=c(0), linetype=\"solid\", color = \"red\", size = 4, alpha = 0.2) + geom_area(aes(y = $countType), alpha=0.1, fill = \"blue\") + ggtitle(\"N=$numGene overallMaxPosCov=$overallMaxPosCov maxPosCov=$posCovLimit minSum=$minTotalCov\") + scale_x_continuous(breaks=seq($plotMinPos, $plotMaxPos, by=$xTick))";
					my $height = 8;
					my $width = 16;
					&ggplotXYLineSingleSample($plotDataHsh_ref, $dataPath, $pdfPath, $RScriptPath, $logPath, $XAXis, $YAxis, $extraArg, $extraStatment, $height, $width);#->3587
				}
			}#---end of else
		}#---end of foreach my $dirtn (@{$dirtnAry_ref})
	}#---end of foreach my $refPt (@{$refPtAry_ref})
	
	return ($rltvPosCovHshPathHsh_ref);
}
sub plotValidPolyASiteAroundGenes {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: plotCoverageAroundGene|3867
#	appearInSub: >none
#	primaryAppearInSection: 1_defineHardCodedParam|104, 7_plotRawDistribution|276
#	secondaryAppearInSection: >none
#	input: $ggplotDirHsh_ref, $initialOutterBound, $mRNAInfoHsh_ref, $mRNAPrxmtyClassListHsh_ref, $nonStructuralCount, $plotInnerBound, $resultLogDir, $resultStorableDir, $validPolyASiteDstrbtnHsh_ref
#	output: 
#	toCall: &plotValidPolyASiteAroundGenes($validPolyASiteDstrbtnHsh_ref, $nonStructuralCount, $initialOutterBound, $plotInnerBound, $ggplotDirHsh_ref, $resultStorableDir, $mRNAInfoHsh_ref, $mRNAPrxmtyClassListHsh_ref, $resultLogDir);
#	calledInLine: 284
#....................................................................................................................................................#
	my ($validPolyASiteDstrbtnHsh_ref, $nonStructuralCount, $initialOutterBound, $plotInnerBound, $ggplotDirHsh_ref, $resultStorableDir, $mRNAInfoHsh_ref, $mRNAPrxmtyClassListHsh_ref, $resultLogDir) = @_;

	my $innerBound = $plotInnerBound;
	my $outterBound = my $margin = $initialOutterBound;
	my $posCovLimit = 100000;
	my $countTypeToPlot = 'proportion';
	#my $countTypeToPlot = 'all';
	my $minTotalCov = 1;
	my $printIndivCovLog = 'yes';
	my $dirTag = 'validPolyASiteDstrbtn';

	my %tmpPrxmtyClassNameHsh = ();
	$tmpPrxmtyClassNameHsh{'head'}{'s'} = 'with.upStrm.tandem';
	$tmpPrxmtyClassNameHsh{'head'}{'a'} = 'with.upStrm.divergent';
	$tmpPrxmtyClassNameHsh{'tail'}{'s'} = 'with.dnStrm.tandem';
	$tmpPrxmtyClassNameHsh{'tail'}{'a'} = 'with.dnStrm.convergent';

	foreach my $headOrTail (keys %{$mRNAPrxmtyClassListHsh_ref}) {
		foreach my $dirtn (keys %{$mRNAPrxmtyClassListHsh_ref->{$headOrTail}}) {
			my $covHsh_ref = $validPolyASiteDstrbtnHsh_ref;
			my $plotTag = $tmpPrxmtyClassNameHsh{$headOrTail}{$dirtn};
			my $refPtAry_ref = [$headOrTail];
			my $dirtnAry_ref = ['s','a'];
			my $itemFilterHsh_ref = $mRNAPrxmtyClassListHsh_ref->{$headOrTail}{$dirtn};
			my $filterShort = 'no';
			(undef) = &plotCoverageAroundGene($covHsh_ref, $margin, $innerBound, $outterBound, $ggplotDirHsh_ref, $nonStructuralCount, $plotTag, $dirTag, $countTypeToPlot, $posCovLimit, $minTotalCov, $resultStorableDir, $itemFilterHsh_ref, $refPtAry_ref, $dirtnAry_ref, $resultLogDir, $filterShort, $printIndivCovLog);#->3867
		}
	}
	
	{#---plot all
		my $covHsh_ref = $validPolyASiteDstrbtnHsh_ref;
		my $plotTag = "all";
		my $refPtAry_ref = ['head', 'tail'];
		my $dirtnAry_ref = ['s','a'];
		my $itemFilterHsh_ref = {'all'=>1};
		my $filterShort = 'no';
		(undef) = &plotCoverageAroundGene($covHsh_ref, $margin, $innerBound, $outterBound, $ggplotDirHsh_ref, $nonStructuralCount, $plotTag, $dirTag, $countTypeToPlot, $posCovLimit, $minTotalCov, $resultStorableDir, $itemFilterHsh_ref, $refPtAry_ref, $dirtnAry_ref, $resultLogDir, $filterShort, $printIndivCovLog);#->3867
	}
	
	return ();
}
sub polymerDiscriminativeRatio {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportStatus|4806
#	appearInSub: countATGssTAAasMotif|1472, countMotifOccurenceInCDSWithShortAndLongCisNAT|1642
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347
#	input: $minFreq, $ngtvSeqHsh_ref, $polymerSize, $pstvSeqHsh_ref
#	output: $countPerKbHsh_ref, $freqHsh_ref, $ratioHsh_ref
#	toCall: my ($ratioHsh_ref, $countPerKbHsh_ref, $freqHsh_ref) = &polymerDiscriminativeRatio($polymerSize, $pstvSeqHsh_ref, $ngtvSeqHsh_ref, $minFreq);
#	calledInLine: 1495, 1713
#....................................................................................................................................................#
	my ($polymerSize, $pstvSeqHsh_ref, $ngtvSeqHsh_ref, $minFreq) = @_;
	
	&reportStatus("Discriminative polymer analysis with $polymerSize nt", 20, "\n");#->4806
	my $regexString = '';
	$regexString .= '{A,C,G,T}' foreach (1..$polymerSize);
	
	my %tmpSeqRefHsh = ('pstv'=>$pstvSeqHsh_ref, 'ngtv'=>$ngtvSeqHsh_ref);

	my $freqHsh_ref = {};
	my $countPerKbHsh_ref = {};
	my $ratioHsh_ref = {};
	my $totalLengthHsh_ref = {'pstv'=>0, 'ngtv'=>0};
	
	foreach (glob $regexString) {
		$freqHsh_ref->{$_}{'pstv'} = 0;
		$freqHsh_ref->{$_}{'ngtv'} = 0;
	}

	my $polymerNum = keys %{$freqHsh_ref};
	
	foreach my $pstvOrNgtv (keys %tmpSeqRefHsh) {
		my $seqHsh_ref = $tmpSeqRefHsh{$pstvOrNgtv};
		foreach my $seqName (keys %{$seqHsh_ref}) {
			$totalLengthHsh_ref->{$pstvOrNgtv} += length($seqHsh_ref->{$seqName})/1000;
		}
	}

	&reportStatus("ngtv total length = $totalLengthHsh_ref->{'ngtv'}", 10, "\n");#->4806
	&reportStatus("pstv total length  = $totalLengthHsh_ref->{'pstv'}", 10, "\n");#->4806

	foreach my $pstvOrNgtv (keys %tmpSeqRefHsh) {
		my $seqHsh_ref = $tmpSeqRefHsh{$pstvOrNgtv};
		my $seqNum = (keys %{$seqHsh_ref});
		my $polymerProc = 0;
		foreach my $polymer (keys %{$freqHsh_ref}) {
			$polymerProc++;
			&reportStatus("$polymerProc of $polymerNum counted in $pstvOrNgtv", 20, "\r");#->4806
			foreach my $seqName (keys %{$seqHsh_ref}) {
				my $count = () = $seqHsh_ref->{$seqName} =~ /$polymer/gi; # count the number of  colours (and colors).
				$freqHsh_ref->{$polymer}{$pstvOrNgtv} += $count;
			}
		}
	}
	
	foreach my $polymer (keys %{$freqHsh_ref}) {
		
		foreach my $pstvOrNgtv (keys %{$freqHsh_ref->{$polymer}}) {
			#---[16/10/2013 13:02] calculate the count per kb
			$countPerKbHsh_ref->{$polymer}{$pstvOrNgtv} = $freqHsh_ref->{$polymer}{$pstvOrNgtv}/$totalLengthHsh_ref->{$pstvOrNgtv};
		}
		
		if ($freqHsh_ref->{$polymer}{'pstv'} < $minFreq or $freqHsh_ref->{$polymer}{'ngtv'} < $minFreq) {
			delete $freqHsh_ref->{$polymer};
			next;
		}
		
		$ratioHsh_ref->{$polymer}{'linear'} = $countPerKbHsh_ref->{$polymer}{'pstv'}/$countPerKbHsh_ref->{$polymer}{'ngtv'};
		$ratioHsh_ref->{$polymer}{'log2'} = log($ratioHsh_ref->{$polymer}{'linear'})/log(2);
	}
	
	return ($ratioHsh_ref, $countPerKbHsh_ref, $freqHsh_ref);
}
sub printBothFHAndStdout {
#....................................................................................................................................................#
#	subroutineCategory: general, reporting
#	dependOnSub: currentTime|1872
#	appearInSub: assignAntiSensePolyAClusterTomRNAHead|502, assignPolyAClusterTomRNABody|573, assignSensePolyAClusterTomRNATail|658, getmRNASeqWithEnd3AntisensePolyA|3379
#	primaryAppearInSection: 4_processGenomeInformation|209, 9_assignPolyAClustersToGenes|300
#	secondaryAppearInSection: 12_investigateEnd3NATPolyA|347, 9_assignPolyAClustersToGenes|300
#	input: $FH, $message, $numTrailingSpace
#	output: 
#	toCall: &printBothFHAndStdout($message, $numTrailingSpace, $FH);
#	calledInLine: 230, 231, 232, 233, 234, 310, 311, 312, 568, 652, 757, 3438
#....................................................................................................................................................#
	
	my ($message, $numTrailingSpace, $FH) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);

	print "[".&currentTime()."] ".$message.$trailingSpaces."\n";#->1872
	print {$FH} "[".&currentTime()."] ".$message."\n";#->1872

	return ();
}
sub printCMDLogOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|1872
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|93, 13_finishingTasks|362
#	secondaryAppearInSection: >none
#	input: $CMDLogOrFinishMessage
#	output: none
#	toCall: &printCMDLogOrFinishMessage($CMDLogOrFinishMessage);
#	calledInLine: 98, 367
#....................................................................................................................................................#

	my ($CMDLogOrFinishMessage) = @_;
	
	if ($CMDLogOrFinishMessage eq "CMDLog") {
		#---open a log file if it doesnt exists
		my $absoluteScriptPath = abs_path($0);
		my $dirPath = dirname(rel2abs($absoluteScriptPath));
		my ($scriptName, $callScriptPath, $scriptSuffix) = fileparse($absoluteScriptPath, qr/\.[^.]*/);
		open (CMDLOG, ">>$dirPath/$scriptName.cmd.log.txt"); #---append the CMD log file
		print CMDLOG "[".&currentTime()."]\t"."$dirPath/$scriptName$scriptSuffix ".(join " ", @ARGV)."\n";#->1872
		close CMDLOG;
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->1872
		print "=========================================================================\n\n";

	} elsif ($CMDLogOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->1872
		print "=========================================================================\n\n";
	}
}
sub printClusterInfoAndWig {
#....................................................................................................................................................#
#	subroutineCategory: specific, reporting
#	dependOnSub: getClstrSequence|2585
#	appearInSub: >none
#	primaryAppearInSection: 10_gatherAndReportPolyAInfo|320
#	secondaryAppearInSection: >none
#	input: $clstrBasedPolyAInfoHsh_ref, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $clstrSeqRng, $fastaHsh_ref, $polyATypeTagHsh_ref, $resultLogDir, $resultWigDir
#	output: 
#	toCall: &printClusterInfoAndWig($clstrBasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $resultLogDir, $resultWigDir, $fastaHsh_ref, $clstrSeqRng);
#	calledInLine: 326
#....................................................................................................................................................#
	my ($clstrBasedPolyAInfoHsh_ref, $polyATypeTagHsh_ref, $clstrInfoHsh_ref, $clstrPeakByPosHsh_ref, $resultLogDir, $resultWigDir, $fastaHsh_ref, $clstrSeqRng) = @_;
	
	#---[06/10/2013 14:26] get clstr sequence
	&getClstrSequence($clstrInfoHsh_ref, $fastaHsh_ref, $clstrSeqRng);#->2585
	
	#---[06/10/2013 17:10] open the FH for wiggle
	my %wiggleFHHsh = ();
	my %tmpStrndWordHsh = ('+'=>'plus', '-'=>'minus');
	foreach my $dirtn (sort keys %{$polyATypeTagHsh_ref}) {
		foreach my $tailOrBodyOrHead (sort keys %{$polyATypeTagHsh_ref->{$dirtn}}) {
			my $polyATypeTag = $polyATypeTagHsh_ref->{$dirtn}{$tailOrBodyOrHead};
			foreach my $strnd (qw/+ -/) {
				my $plusOrMinus = $tmpStrndWordHsh{$strnd};
				my $path = "$resultWigDir/category.$polyATypeTag.$plusOrMinus.wig.gz";
				open $wiggleFHHsh{$polyATypeTag}{$strnd}, "| gzip -fc >$path";
			}
		}
	}
	
	open CLSTRINFO, ">", "$resultLogDir/clstr.info.xls";
	
	#---[06/10/2013 14:50]  print the header
	my @headerAry = (qw/clstrID cntg strnd siteNum peakPos peakRdNum peakALen avgRdNum avgALen clstrSize posStr rdNumStr ALenStr/);
	foreach my $dirtn (sort keys %{$polyATypeTagHsh_ref}) {
		foreach my $tailOrBodyOrHead (sort keys %{$polyATypeTagHsh_ref->{$dirtn}}) {
			my $polyATypeTag = $polyATypeTagHsh_ref->{$dirtn}{$tailOrBodyOrHead};
			push @headerAry, ($polyATypeTag."_mRNAID", $polyATypeTag."_CDSLength", $polyATypeTag."_distFromCDSEnd", $polyATypeTag."_longALen", $polyATypeTag."_peak", $polyATypeTag."_close", $polyATypeTag."_far");
		}
	}
	push @headerAry, (qw/upStrmSeq dnStrmSeq/);
	print CLSTRINFO join "", (join "\t", (@headerAry)), "\n";

	#---[06/10/2013 14:50] print clstr info
	foreach my $cntg (sort keys %{$clstrPeakByPosHsh_ref}) {
		
		#---[06/10/2013 17:21] print the wiggle cntg
		foreach my $polyATypeTag (keys %wiggleFHHsh) {
			foreach my $strnd (keys %{$wiggleFHHsh{$polyATypeTag}}) {
				print {$wiggleFHHsh{$polyATypeTag}{$strnd}} "variableStep chrom=$cntg span=1\n";
			}
		}
		
		foreach my $peakPos (sort {$a <=> $b} keys %{$clstrPeakByPosHsh_ref->{$cntg}}) {
			foreach my $strnd (sort keys %{$clstrPeakByPosHsh_ref->{$cntg}{$peakPos}}) {
				my $clstrID = $clstrPeakByPosHsh_ref->{$cntg}{$peakPos}{$strnd};
				my $siteNum = $clstrInfoHsh_ref->{$clstrID}{'siteNum'};
				my $peakRdNum = $clstrInfoHsh_ref->{$clstrID}{'peakRdNum'};
				my $peakALen = $clstrInfoHsh_ref->{$clstrID}{'peakALen'};
				my $avgRdNum = $clstrInfoHsh_ref->{$clstrID}{'avgRdNum'};
				my $avgALen = $clstrInfoHsh_ref->{$clstrID}{'avgALen'};
				my $clstrSize = $clstrInfoHsh_ref->{$clstrID}{'clstrSize'};
				my $posStr = $clstrInfoHsh_ref->{$clstrID}{'posStr'};
				my $rdNumStr = $clstrInfoHsh_ref->{$clstrID}{'rdNumStr'};
				my $ALenStr = $clstrInfoHsh_ref->{$clstrID}{'ALenStr'};

				my @outputAry = ($clstrID, $cntg, $strnd, $siteNum, $peakPos, $peakRdNum, $peakALen, $avgRdNum, $avgALen, $clstrSize, $posStr, $rdNumStr, $ALenStr);

				foreach my $dirtn (sort keys %{$polyATypeTagHsh_ref}) {
					foreach my $tailOrBodyOrHead (sort keys %{$polyATypeTagHsh_ref->{$dirtn}}) {
						my $mRNAID = 'none';
						my $CDSLength = 'none';
						my $distFromCDSEnd = 'none';
						my $longALen = 'none';
						my $peak = 'none';
						my $close = 'none';
						my $far = 'none';
						my $polyATypeTag = $polyATypeTagHsh_ref->{$dirtn}{$tailOrBodyOrHead};
						if ($clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}) {
							$mRNAID = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'mRNAID'};
							$CDSLength = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'CDSLength'};
							$distFromCDSEnd = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'distFromCDSEnd'};
							$longALen = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'longALen'};
							$peak = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'peak'};
							$close = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'close'};
							$far = $clstrBasedPolyAInfoHsh_ref->{$clstrID}{$polyATypeTag}{'far'};

							#---[06/10/2013 17:14] print the wiggle
							my @posAry = split /;/, $posStr;
							my @rdNumAry = split /;/, $rdNumStr;
							foreach my $i (0..$#posAry) {
								my $pos = $posAry[$i];
								my $rdNum = $rdNumAry[$i];
								print {$wiggleFHHsh{$polyATypeTag}{$strnd}} join "", (join "\t", ($pos, $rdNum)), "\n";
							}
						}
						push @outputAry, ($mRNAID, $CDSLength, $distFromCDSEnd, $longALen, $peak, $close, $far);
					}
				}
		
				my $upStrmSeq = $clstrInfoHsh_ref->{$clstrID}{'upStrmSeq'};
				my $dnStrmSeq = $clstrInfoHsh_ref->{$clstrID}{'dnStrmSeq'};
				push @outputAry, ($upStrmSeq, $dnStrmSeq);
				print CLSTRINFO join "", (join "\t", (@outputAry)), "\n";
			}
		}
	}
	close CLSTRINFO;
	return ();
}
sub printGeneBasedInfo {
#....................................................................................................................................................#
#	subroutineCategory: specfic, reporting
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 10_gatherAndReportPolyAInfo|320
#	secondaryAppearInSection: >none
#	input: $mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $polyATypeTagHsh_ref, $resultLogDir
#	output: 
#	toCall: &printGeneBasedInfo($mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $resultLogDir, $polyATypeTagHsh_ref);
#	calledInLine: 327
#....................................................................................................................................................#
	my ($mRNABasedPolyAInfoHsh_ref, $mRNAInfoHsh_ref, $resultLogDir, $polyATypeTagHsh_ref) = @_;
	
	foreach my $dirtn (sort keys %{$mRNABasedPolyAInfoHsh_ref}) {
		foreach my $tailOrBodyOrHead (sort keys %{$mRNABasedPolyAInfoHsh_ref->{$dirtn}}) {
			my $polyATypeTag = $polyATypeTagHsh_ref->{$dirtn}{$tailOrBodyOrHead};
			open GENEPOLYALOG, ">", "$resultLogDir/category.$polyATypeTag.gene.based.polyA.info.xls";
			my @headerAry = (qw/mRNAID description cntg strnd CDSStart CDSEnd fromNeigbhor clstrIDStr rltvPosStr rdNumStr clstrNum avgALen avgRdNum closeRltvPos farRltvPos peakRltvPos longALenRltvPos closeClstrID farClstrID peakClstrID longALenClstrID peakRdNum peakALen peakPos/);
			print GENEPOLYALOG join "", (join "\t", (@headerAry)), "\n";
			
			foreach my $mRNAID (sort keys %{$mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}}) {
				my $cntg = $mRNAInfoHsh_ref->{$mRNAID}{'cntg'};
				my $strnd = $mRNAInfoHsh_ref->{$mRNAID}{'strnd'};
				my $description = $mRNAInfoHsh_ref->{$mRNAID}{'description'};
				@{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}} = sort {$a <=> $b} @{$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}};
				my ($CDSStart, $CDSEnd) = (${$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}}[0], ${$mRNAInfoHsh_ref->{$mRNAID}{'CDSRng'}}[-1]);
				my $fromNeigbhor = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'fromNeigbhor'};
				my $clstrIDStr = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'clstrIDStr'};
				my $rltvPosStr = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'rltvPosStr'};
				my $rdNumStr = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'rdNumStr'};
				my $ALenStr = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'ALenStr'};
				my $clstrNum = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'clstrNum'};
				my $avgALen = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'avgALen'};
				my $avgRdNum = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'avgRdNum'};
				my $closeRltvPos = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'closeRltvPos'};
				my $farRltvPos = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'farRltvPos'};
				my $peakRltvPos = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakRltvPos'};
				my $longALenRltvPos = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'longALenRltvPos'};
				my $closeClstrID = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'closeClstrID'};
				my $farClstrID = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'farClstrID'};
				my $peakClstrID = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakClstrID'};
				my $longALenClstrID = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'longALenClstrID'};
				my $peakRdNum = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakRdNum'};
				my $peakALen = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakALen'};
				my $peakPos = $mRNABasedPolyAInfoHsh_ref->{$dirtn}{$tailOrBodyOrHead}{$mRNAID}{'peakPos'};
				my @outputAry = ($mRNAID, $description, $cntg, $strnd, $CDSStart, $CDSEnd, $fromNeigbhor, $clstrIDStr, $rltvPosStr, $rdNumStr, $clstrNum, $avgALen, $avgRdNum, $closeRltvPos, $farRltvPos, $peakRltvPos, $longALenRltvPos, $closeClstrID, $farClstrID, $peakClstrID, $longALenClstrID, $peakRdNum, $peakALen, $peakPos);
				print GENEPOLYALOG join "", (join "\t", (@outputAry)), "\n";
			}
		}
	}
	close GENEPOLYALOG;

	return ();
}
sub printPrxmtyInfoLog {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $hitAndPrxmtyByRefHsh_ref, $nameTag, $qryInfoHsh_ref, $refInfoHsh_ref, $resultLogDir
#	output: 
#	toCall: &printPrxmtyInfoLog($hitAndPrxmtyByRefHsh_ref, $refInfoHsh_ref, $qryInfoHsh_ref, $resultLogDir, $nameTag);
#	calledInLine: 221
#....................................................................................................................................................#
	my ($hitAndPrxmtyByRefHsh_ref, $refInfoHsh_ref, $qryInfoHsh_ref, $resultLogDir, $nameTag) = @_;
	
	#---default value
	$nameTag = 'item' if not $nameTag;
	
	open PRXMTYLOG, ">", "$resultLogDir/$nameTag.hitAndPrxmty.xls";
	foreach my $refID (sort keys %{$refInfoHsh_ref}) {
		my @outputAry = qw/refID ctgry location strnd/;
		foreach my $XSOrSS (keys %{$hitAndPrxmtyByRefHsh_ref}) {
			push @outputAry, ("$XSOrSS.hitID", "$XSOrSS.hitCtgry", "$XSOrSS.hitDirtn");
			if ($hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'prxmty'}{$refID}) {
				foreach my $HOrT (sort keys %{$hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'prxmty'}{$refID}}) {
					push @outputAry, ("$XSOrSS.$HOrT.prxmtyID", "$XSOrSS.$HOrT.prxmtyCtrgy", "$XSOrSS.$HOrT.prxmtyDist", "$XSOrSS.$HOrT.prxmtyDirtn");
				}
			}
		}
		print PRXMTYLOG join "", ((join "\t", @outputAry), "\n");
		last;
	}
	
	foreach my $refID (sort keys %{$refInfoHsh_ref}) {
		my $ctgry = $refInfoHsh_ref->{$refID}{'ctgry'};
		my $location = $refInfoHsh_ref->{$refID}{'cntg'}.":".$refInfoHsh_ref->{$refID}{'geneRng'}->[0]."-".$refInfoHsh_ref->{$refID}{'geneRng'}->[1];
		my $strnd = $refInfoHsh_ref->{$refID}{'strnd'};
		my @outputAry = ($refID, $ctgry, $location, $strnd);

		foreach my $XSOrSS (keys %{$hitAndPrxmtyByRefHsh_ref}) {
			my @hitIDAry = my @hitCtgryAry = my @hitDirtnAry = ('none');
			if ($hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'hit'}{$refID}) {
				@hitIDAry = @hitCtgryAry = @hitDirtnAry =();
				foreach my $qryID (sort keys %{$hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'hit'}{$refID}}) {
					push @hitIDAry, $qryID;
					push @hitCtgryAry, $qryInfoHsh_ref->{$qryID}{'ctgry'};
					my $dirtn = 's';
					$dirtn = 'a' if $refInfoHsh_ref->{$refID}{'strnd'} ne $qryInfoHsh_ref->{$qryID}{'strnd'};
					push @hitDirtnAry, $dirtn;
				}
			}
			
			my $hitIDStr = join ",", @hitIDAry;
			my $hitCtgryStr = join ",", @hitCtgryAry;
			my $hitDirtnStr = join ",", @hitDirtnAry;
			push @outputAry, ($hitIDStr, $hitCtgryStr, $hitDirtnStr);
			
			if ($hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'prxmty'}{$refID}) {
				foreach my $HOrT (sort keys %{$hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'prxmty'}{$refID}}) {
					my ($qryDist, $qryID) = @{$hitAndPrxmtyByRefHsh_ref->{$XSOrSS}{'prxmty'}{$refID}{$HOrT}};
					my $qryCtrgy = 'edge';
					my $dirtn = 'edge';
					if ($qryInfoHsh_ref->{$qryID}) {
						$dirtn = 's';
						$dirtn = 'a' if $refInfoHsh_ref->{$refID}{'strnd'} ne $qryInfoHsh_ref->{$qryID}{'strnd'};
						$qryCtrgy = $qryInfoHsh_ref->{$qryID}{'ctgry'};
					}
					push @outputAry, ($qryID, $qryCtrgy, $qryDist, $dirtn);
				}
			}
		}
		print PRXMTYLOG join "", ((join "\t", @outputAry), "\n");
	}
	close PRXMTYLOG;

	return ();
}
sub printWigFromCovPerlStorable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkRunningThreadAndWaitToJoin|1227, reportStatus|4806
#	appearInSub: filterValidPolyASite|2140, getRawPolyASite|2977
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 5_getValidPolyASitesAndPlotRawDistribution|245, 6_filterAbovebackgroundPolyASites|263
#	input: $IGVGenomePath, $covPlsPathHsh_ref, $wigPrefix
#	output: none
#	toCall: &printWigFromCovPerlStorable($covPlsPathHsh_ref, $wigPrefix, $IGVGenomePath);
#	calledInLine: 2216, 3038, 3039
#....................................................................................................................................................#

	my ($covPlsPathHsh_ref, $wigPrefix, $IGVGenomePath) = @_;

	my $wigInfoHsh_ref = {};
	
	foreach my $plusOrMinus (qw/plus minus/) {
		my $path = "$wigPrefix.$plusOrMinus.wig.gz";
		$wigInfoHsh_ref->{$plusOrMinus}{'path'} = $path;
		open $wigInfoHsh_ref->{$plusOrMinus}{'FH'}, "| gzip -fc >$path";
	}
	
	foreach my $cntg (sort {$a cmp $b} keys %{$covPlsPathHsh_ref}) {
		my $cntgCovPlsPath = $covPlsPathHsh_ref->{$cntg};
		&reportStatus("Writing $cntg", 20,"\r");#->4806

		my $cntgCovAry_ref = retrieve($cntgCovPlsPath);

		foreach my $plusOrMinus (keys %{$wigInfoHsh_ref}) {
			print {$wigInfoHsh_ref->{$plusOrMinus}{'FH'}} "variableStep chrom=$cntg span=1\n";
		}

		foreach my $index (0..$#{$cntgCovAry_ref}) {
			if (defined $cntgCovAry_ref->[$index]) {
				my $pos = $index+1;
				my %strandCountHsh = ();
				($strandCountHsh{'plus'}, $strandCountHsh{'minus'}) = split /,/, $cntgCovAry_ref->[$index];
				foreach my $plusOrMinus (keys %strandCountHsh) {
					my $count = $strandCountHsh{$plusOrMinus};
					print {$wigInfoHsh_ref->{$plusOrMinus}{'FH'}} join '', ((join "\t", ($pos, $count)), "\n") if ($count > 0);
				}
			}
		}
	}
	
	foreach my $plusOrMinus (keys %{$wigInfoHsh_ref}) {
		close $wigInfoHsh_ref->{$plusOrMinus}{'FH'};
	}
	
	foreach my $plusOrMinus (keys %{$wigInfoHsh_ref}) {
		my $path = $wigInfoHsh_ref->{$plusOrMinus}{'path'};
		my $cmd = "igvtools toTDF $path $wigPrefix.$plusOrMinus.tdf $IGVGenomePath 2&>/dev/null;";
		&reportStatus("Issue a thread to convert $plusOrMinus wig", 0, "\n");#->4806
		threads->create(sub{system $cmd;});
	}
	
	&checkRunningThreadAndWaitToJoin('yes', 1);#->1227

}
sub readGFF_oneRNAPerGene {
#....................................................................................................................................................#
#	subroutineCategory: general, gff
#	dependOnSub: currentTime|1872
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $gffPath
#	output: $geneInfoHsh_ref
#	toCall: my ($geneInfoHsh_ref) = &readGFF_oneRNAPerGene($gffPath);
#	calledInLine: 216
#....................................................................................................................................................#

	my ($gffPath) = @_;

	my $geneInfoHsh_ref = {};
	
	#---read the gff
	my $geneByRNAHsh_ref = {};

	open (GFF, $gffPath);
	print "[".&currentTime()."] Reading: $gffPath\n";#->1872
	while (my $theLine = <GFF>) {

		chomp $theLine;
		
		last if $theLine =~ m/^##FASTA/;
		
		if ($theLine !~ m/^\#|^\@/ and $theLine !~ m/\tsupercontig\t/) {

			my ($seq, undef, $geneCategory, $featureStart, $featureEnd, undef, $geneStrd, undef, $dscrptns) = split (/\t/, $theLine);
			
			#----assigne all non -/+ will be treated as plus
			$geneStrd = "+" if (($geneStrd ne "-") and ($geneStrd ne "+"));
			
			my @dscrptnsSplt = split /;/, $dscrptns;
			my ($unqID, $parent);
			my $geneName = "unknown";
			foreach my $theDscptn (@dscrptnsSplt) {
				if ($theDscptn =~ m/^ID=/) {$unqID = substr ($theDscptn, index ($theDscptn, "=")+1);}
				if ($theDscptn =~ m/^Parent=/) {$parent = substr ($theDscptn, index ($theDscptn, "=")+1);}
				if ($theDscptn =~ m/^description=/) {$geneName = substr ($theDscptn, index ($theDscptn, "=")+1);}
			}

			if ($geneCategory eq "gene") {#---gene
				
				my $geneID = $unqID;
				$geneInfoHsh_ref->{$geneID}{'strnd'} = $geneStrd;
				$geneInfoHsh_ref->{$geneID}{'cntg'} = $seq;
				$geneInfoHsh_ref->{$geneID}{'description'} = uri_unescape($geneName);
				$geneInfoHsh_ref->{$geneID}{'description'} =~ s/\+/ /g;
				@{$geneInfoHsh_ref->{$geneID}{'geneRng'}} = ($featureStart, $featureEnd);

			} elsif ($geneCategory eq "CDS") {#---Only for coding genes
				
				my $RNAID = $parent;
				next if not $geneByRNAHsh_ref->{$RNAID};

				my $geneID = $geneByRNAHsh_ref->{$RNAID};
				push @{$geneInfoHsh_ref->{$geneID}{'CDSRng'}}, ($featureStart, $featureEnd);
				
			} elsif ($geneCategory eq "exon") {#---exon, may be exons of alternative transcripts, wiull sort out later
				my $RNAID = $parent;
				next if not $geneByRNAHsh_ref->{$RNAID};

				my $geneID = $geneByRNAHsh_ref->{$RNAID};
				push @{$geneInfoHsh_ref->{$geneID}{'exonRng'}}, ($featureStart, $featureEnd);
				
			} else {#---can be tRNA, rRNA, mRNA, repRNA, ncRNA
				my $RNAID = $unqID;
				my $geneID = $parent;
				next if not $geneID;
				
				$geneByRNAHsh_ref->{$RNAID} = $geneID;
				$geneInfoHsh_ref->{$geneID}{'ctgry'} = $geneCategory;
				@{$geneInfoHsh_ref->{$geneID}{'RNARng'}} = ($featureStart, $featureEnd);
				$geneInfoHsh_ref->{$geneID}{'RNAID'} = $RNAID;
			}
		}#---end of if (($theLine !~ m/^\#|^\@/) and ($theLine !~ m/\tsupercontig\t/)) {
	}#---end of while (my $theLine = <INFILE>)
	close GFF;
	
	#---get the UTR if any
	my $minUTRLength = 10;
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		
		#---remove genes without exon
		if (not $geneInfoHsh_ref->{$geneID}{'exonRng'}) {
			delete $geneInfoHsh_ref->{$geneID};
			next;
		}
		
		if (exists $geneInfoHsh_ref->{$geneID}{'CDSRng'}) {
			my $exonMin = min(@{$geneInfoHsh_ref->{$geneID}{'exonRng'}});
			my $exonMax = max(@{$geneInfoHsh_ref->{$geneID}{'exonRng'}});
			my $CDSMin = min(@{$geneInfoHsh_ref->{$geneID}{'CDSRng'}});
			my $CDSMax = max(@{$geneInfoHsh_ref->{$geneID}{'CDSRng'}});

			if ($geneInfoHsh_ref->{$geneID}{'strnd'} eq '+') {
				@{$geneInfoHsh_ref->{$geneID}{'UTR5Rng'}} = ($exonMin, $CDSMin-1) if ($CDSMin-$exonMin > $minUTRLength);
				@{$geneInfoHsh_ref->{$geneID}{'UTR3Rng'}} = ($CDSMax+1, $exonMax) if ($exonMax-$CDSMax > $minUTRLength);
			} else {
				@{$geneInfoHsh_ref->{$geneID}{'UTR3Rng'}} = ($exonMin, $CDSMin-1) if ($CDSMin-$exonMin > $minUTRLength);
				@{$geneInfoHsh_ref->{$geneID}{'UTR5Rng'}} = ($CDSMax+1, $exonMax) if ($exonMax-$CDSMax > $minUTRLength);
			}
		}
	}
	
	return ($geneInfoHsh_ref);
}
sub readMultiFasta {
#....................................................................................................................................................#
#	subroutineCategory: fasta, general
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 4_processGenomeInformation|209
#	secondaryAppearInSection: >none
#	input: $fastaPath
#	output: $fastaHsh_ref
#	toCall: my ($fastaHsh_ref) = &readMultiFasta($fastaPath);
#	calledInLine: 215
#....................................................................................................................................................#

	my ($fastaPath) = @_;

	my ($seq, $seqName);
	my $fastaHsh_ref = {};
	my $i = 0;

	&reportStatus("Reading: $fastaPath", 0, "\n");#->4806
	
	open (INFILE, $fastaPath);
	chomp (my $curntLine = <INFILE>); #get the first line
	while (my $nextLine = <INFILE>) {
		chomp $nextLine;
		
		#---Only two types of line in current line, the header or seq
		if ($curntLine =~ m/^>/) {#-- header line
			my @theLineSplt = split (/ /, $curntLine);
			$seqName = $theLineSplt[0]; #---get the first tag
			$seqName =~ s/ //g; #---remove space
			$seqName =~ s/>//g; #---remove space
		} else {#--seq line
			$seq = $seq.$curntLine;
		}
		
		#---check if next line has a > or that's the end of file
		if ($nextLine =~ m/^>/) {
			$seq =~ tr/a-z/A-Z/;
			$fastaHsh_ref->{$seqName} = $seq;
			$seq = "";
		} elsif (eof(INFILE)) {#---this is the last line
			$seq =~ tr/a-z/A-Z/;
			$seq = $seq.$nextLine;
			$fastaHsh_ref->{$seqName} = $seq;
		}
		
		#---next line becomes current line
		$curntLine = $nextLine;
	}

	close INFILE;
	return ($fastaHsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|93
#	secondaryAppearInSection: >none
#	input: none
#	output: $IGVGenomePath, $controlPileupIndexPath, $fastaPath, $gffPath, $mRNATrnsfrgOvrlpInfoHshPlsPath, $maxThread, $outDir, $polyACntgPosAvgTailLenHshPlsPath, $tophatBEDPath
#	toCall: my ($gffPath, $fastaPath, $polyACntgPosAvgTailLenHshPlsPath, $controlPileupIndexPath, $IGVGenomePath, $maxThread, $tophatBEDPath, $mRNATrnsfrgOvrlpInfoHshPlsPath, $outDir) = &readParameters();
#	calledInLine: 99
#....................................................................................................................................................#
	
	my ($gffPath, $fastaPath, $polyACntgPosAvgTailLenHshPlsPath, $controlPileupIndexPath, $IGVGenomePath, $maxThread, $tophatBEDPath, $mRNATrnsfrgOvrlpInfoHshPlsPath, $outDir);
	
	$maxThread = 4;
	my $dirPath = dirname(rel2abs($0));
	$outDir = "$dirPath/polyATailFinder/";
	$tophatBEDPath = undef;
	$mRNATrnsfrgOvrlpInfoHshPlsPath = 'none';
	
	GetOptions 	("gffPath=s"  => \$gffPath,
				 "fastaPath=s"  => \$fastaPath,
				 "polyACntgPosAvgTailLenHshPlsPath=s"  => \$polyACntgPosAvgTailLenHshPlsPath,
				 "mRNATrnsfrgOvrlpInfoHshPlsPath=s"  => \$mRNATrnsfrgOvrlpInfoHshPlsPath,
				 "controlPileupIndexPath=s"  => \$controlPileupIndexPath,
				 "IGVGenomePath=s"  => \$IGVGenomePath,
				 "tophatBEDPath:s"  => \$tophatBEDPath,
				 "maxThread:i"  => \$maxThread,
				 "outDir:s"  => \$outDir)

	or die		("Error in command line arguments\n");
	
	#---check file
	foreach my $fileToCheck ($mRNATrnsfrgOvrlpInfoHshPlsPath, $gffPath, $fastaPath, $polyACntgPosAvgTailLenHshPlsPath, $controlPileupIndexPath, $IGVGenomePath) {
		die "Can't read $fileToCheck" if not -s $fileToCheck and $fileToCheck ne 'none';
	}

	system "mkdir -p -m 777 $outDir/";
	
	return($gffPath, $fastaPath, $polyACntgPosAvgTailLenHshPlsPath, $controlPileupIndexPath, $IGVGenomePath, $maxThread, $tophatBEDPath, $mRNATrnsfrgOvrlpInfoHshPlsPath, $outDir);
}
sub readTophatBEDFile {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 9_assignPolyAClustersToGenes|300
#	secondaryAppearInSection: >none
#	input: $resultStorableDir, $tophatBEDPath
#	output: $jnctnByPosHsh_ref, $tophatJnctnInfoHsh_ref
#	toCall: my ($tophatJnctnInfoHsh_ref, $jnctnByPosHsh_ref) = &readTophatBEDFile($tophatBEDPath, $resultStorableDir);
#	calledInLine: 309
#....................................................................................................................................................#

	
	#	track name=junctions description="TopHat junctions"
	#	DS571731	2015	2246	JUNC00000001	20	+	2015	2246	255,0,0	2	92,94	0,137
	#	DS571736	1442	1672	JUNC00000002	10	+	1442	1672	255,0,0	2	94,77	0,153
	#	DS571148	19849	20136	JUNC00000003	1	-	19849	20136	255,0,0	2	92,8	0,279
	#	0			1		2		3				4	5	6		7		8		9	10		11
	my ($tophatBEDPath, $resultStorableDir) = @_;
	
	my $tophatJnctnInfoHsh_ref = {};
	my $tophatJnctnInfoHshPlsPath = "$resultStorableDir/tophatJnctnInfoHsh.pls";

	my $jnctnByPosHsh_ref = {};
	my $jnctnByPosHshPlsPath = "$resultStorableDir/jnctnByPosHsh.pls";
	
	if (-s $tophatJnctnInfoHshPlsPath and -s $jnctnByPosHshPlsPath) {
		
		&reportStatus("Retrieving tophatJnctnInfoHsh and jnctnByPosHsh", 10, "\n");#->4806
		$tophatJnctnInfoHsh_ref = retrieve($tophatJnctnInfoHshPlsPath);
		$jnctnByPosHsh_ref = retrieve($jnctnByPosHshPlsPath);
		
	} elsif (-s $tophatBEDPath) {
		
		open INFILE, "<", "$tophatBEDPath";
		&reportStatus("Reading junction BED file", 10, "\n");#->4806

		while (my $theLine = <INFILE>) {
			next if ($theLine =~ m/^track name/);
			my ($cntg, $cntgStart, $cntgEnd, $juncID, $readNum, $strnd, undef, undef, undef, undef, $blkSize ) = split /\t/, $theLine;
			my ($blkSize1, $blkSize2) = split /,/, $blkSize;
			my $intronStart = $cntgStart + $blkSize1;
			my $intronEnd = $cntgEnd - $blkSize2 - 1;		
			my $jnctnStr = $cntg.":".$intronStart.":".$intronEnd;
			my $intronSize = abs ($intronStart - $intronEnd);
		
			$tophatJnctnInfoHsh_ref->{$jnctnStr}{'readNum'} = $readNum;
			$tophatJnctnInfoHsh_ref->{$jnctnStr}{'intronStart'} = $intronStart;
			$tophatJnctnInfoHsh_ref->{$jnctnStr}{'intronEnd'} = $intronEnd;
			$tophatJnctnInfoHsh_ref->{$jnctnStr}{'intronSize'} = $intronSize;
			$tophatJnctnInfoHsh_ref->{$jnctnStr}{'strnd'} = $strnd;
			$tophatJnctnInfoHsh_ref->{$jnctnStr}{'cntg'} = $cntg;
			push @{$jnctnByPosHsh_ref->{$cntg}{$strnd}}, [$intronStart, $intronEnd];
		}
		close INFILE;

		my $topHatJuncNum = keys %{$tophatJnctnInfoHsh_ref};
		&reportStatus("Totally $topHatJuncNum junctions stored", 10, "\n");#->4806
		
		store($tophatJnctnInfoHsh_ref, $tophatJnctnInfoHshPlsPath);
		store($jnctnByPosHsh_ref, $jnctnByPosHshPlsPath);
	}
	
	return ($tophatJnctnInfoHsh_ref, $jnctnByPosHsh_ref);
}
sub reportStatus {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|1872
#	appearInSub: assignAntiSensePolyAClusterTomRNAHead|502, assignPolyAClusterTomRNABody|573, assignSensePolyAClusterTomRNATail|658, calculateBaseCompositionInAlignments|762, calculatePolyAOccurenceWithinCDSOnBothStrand|815, checkGeneInfo|959, checkOverlapAndProximity|987, checkRunningThreadAndWaitToJoin|1227, checkmRNAProximity|1255, classifymRNABasedOnProximity|1286, clusterPolyASites|1334, countATGssTAAasMotif|1472, countCtgryOnCntg|1521, countMotifOccurenceInCDSWithShortAndLongCisNAT|1642, createEmptyGenomeCovPerlStorable|1770, defineCDSWithLongAndShortCisNAT|1890, dremeATGssTAAasMotif|1979, dremePolyASiteMotif|2040, filterValidPolyASite|2140, gatherPolyAInfo|2224, generateCleavageSiteWeblogoAndMotifFile|2400, generateGeneByCntgHsh|2537, getClstrSequence|2585, getCoverageOfItemRngType_multiStrand|2627, getEnd3SequenceForCDSWithLongAndShortNAT|2771, getIndivCntgCovPlsPath|2824, getIntergenicDistanceAndCDSLength|2857, getRawPolyASite|2977, getSenseTailPolyASiteDistribution|3047, getSeqOfItemRngType|3144, getUTR3AndCDSPosCov|3212, getValidPolyASiteDistribution|3344, getmRNASeqWithEnd3AntisensePolyA|3379, optimizeGapSizeAndClstrPolyASites|3657, plotBaseCompositionClstrPeak|3750, plotCDSToUTR3Ratio|3801, plotCoverageAroundGene|3867, polymerDiscriminativeRatio|4102, printWigFromCovPerlStorable|4474, readMultiFasta|4644, readTophatBEDFile|4740, trainingUsingCDSVsUTR3|4829
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 10_gatherAndReportPolyAInfo|320, 11_investigatePolyAClstrMotif|333, 12_investigateEnd3NATPolyA|347, 4_processGenomeInformation|209, 5_getValidPolyASitesAndPlotRawDistribution|245, 6_filterAbovebackgroundPolyASites|263, 7_plotRawDistribution|276, 8_findOptimalGapSizeAndClusterPolyASites|290, 9_assignPolyAClustersToGenes|300
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 520, 525, 539, 591, 596, 614, 678, 683, 704, 799, 831, 856, 973, 981, 1032, 1046, 1058, 1250, 1271, 1274, 1303, 1327, 1365, 1515, 1539, 1553, 1597, 1636, 1637, 1704, 1733, 1757, 1760, 1791, 1909, 1961, 2027, 2030, 2095, 2128, 2131, 2156, 2160, 2171, 2248, 2277, 2414, 2550, 2598, 2655, 2699, 2728, 2809, 2852, 2876, 2883, 2995, 2999, 3011, 3016, 3065, 3073, 3205, 3233, 3318, 3360, 3399, 3405, 3677, 3694, 3698, 3741, 3772, 3846, 3906, 3933, 4115, 4140, 4141, 4149, 4498, 4526, 4662, 4768, 4775, 4797, 4846
#....................................................................................................................................................#
	
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->1872

	return ();
	
}
sub trainingUsingCDSVsUTR3 {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: getUTR3AndCDSPosCov|3212, plotCDSToUTR3Ratio|3801, reportStatus|4806
#	appearInSub: >none
#	primaryAppearInSection: 6_filterAbovebackgroundPolyASites|263
#	secondaryAppearInSection: >none
#	input: $abvBkgdPctCutoffHsh_ref, $controlPileupPlsPathHsh_ref, $ggplotDirHsh_ref, $mRNAByCntgHsh_ref, $mRNAInfoHsh_ref, $maxThread, $rawPolyASitePlsPathHsh_ref, $resultStorableDir
#	output: $abvBkgdValCutoffHsh_ref
#	toCall: my ($abvBkgdValCutoffHsh_ref) = &trainingUsingCDSVsUTR3($controlPileupPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $maxThread, $ggplotDirHsh_ref, $abvBkgdPctCutoffHsh_ref, $resultStorableDir);
#	calledInLine: 268
#....................................................................................................................................................#
	my ($controlPileupPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $maxThread, $ggplotDirHsh_ref, $abvBkgdPctCutoffHsh_ref, $resultStorableDir) = @_;
	
	my $abvBkgdValCutoffHsh_ref = {};
	my $abvBkgdValCutoffHshPlsPath = "$resultStorableDir/abvBkgdValCutoffHsh.pls";
	
	if (-s $abvBkgdValCutoffHshPlsPath) {
		&reportStatus("Retrieving abvBkgdValCutoffHsh. Skipping UTR3 EXON training", 10, "\n");#->4806
		$abvBkgdValCutoffHsh_ref = retrieve($abvBkgdValCutoffHshPlsPath)
		
	} else {
		
		my $margin = 100;
		my $CDSNumPosPerGene = 20;
		my ($covPairHsh_ref) = &getUTR3AndCDSPosCov($controlPileupPlsPathHsh_ref, $rawPolyASitePlsPathHsh_ref, $mRNAInfoHsh_ref, $mRNAByCntgHsh_ref, $maxThread, $margin, $CDSNumPosPerGene);#->3212
	
		my $plotTag = 'CDSVsUTR3Training';
		my $dataPairTypeStatHsh_ref = {};
		($abvBkgdValCutoffHsh_ref, $dataPairTypeStatHsh_ref) = &plotCDSToUTR3Ratio($covPairHsh_ref, $ggplotDirHsh_ref, $abvBkgdPctCutoffHsh_ref, $plotTag);#->3801
		store($abvBkgdValCutoffHsh_ref, $abvBkgdValCutoffHshPlsPath)

	}
	
	
	return ($abvBkgdValCutoffHsh_ref);
}
sub zipUnzipCntgCovInPlsPathHsh {
#....................................................................................................................................................#
#	subroutineCategory: storable
#	dependOnSub: currentTime|1872
#	appearInSub: >none
#	primaryAppearInSection: 5_getValidPolyASitesAndPlotRawDistribution|245
#	secondaryAppearInSection: >none
#	input: $cntgCovInPlsPathHsh_ref, $zipUnzip
#	output: none
#	toCall: &zipUnzipCntgCovInPlsPathHsh($zipUnzip, $cntgCovInPlsPathHsh_ref);
#	calledInLine: 253, 254, 258
#....................................................................................................................................................#

	my ($zipUnzip, $cntgCovInPlsPathHsh_ref) = @_;
	
	foreach my $cntg (sort keys %{$cntgCovInPlsPathHsh_ref}) {
		print "[".&currentTime()."] $zipUnzip cntg ary.                \r";#->1872
		my $cntgCovPlsPath = "$cntgCovInPlsPathHsh_ref->{$cntg}";
		if ($zipUnzip eq 'unzip') {
			system ("gzip -df $cntgCovPlsPath.gz") if (-s "$cntgCovPlsPath.gz");
		} else {
			system ("gzip -f $cntgCovPlsPath") if (-s "$cntgCovPlsPath");
		}
	}
	print "\n";
}

exit;
